data-1:
    components:
        services:
            cache:
                api:
                    programmer: itham
                    program::
                        def new(name):
                            return run$python(native, mapping(name = name)) <- native:
                                from stuphos.runtime.architecture import writeprotected
                                from stuphos.kernel import vmCurrentTask, resolve_procedure
                        
                                class Cache(writeprotected):
                                    def __init__(self, name, ns = None):
                                        self._name = name
                                        self._ns = dict() if ns is None else ns
                            
                                    def key(self, name):
                                        return f'{self._name}-{name}'
                            
                                    def get(self, name):
                                        return self._ns[self.key(name)]
                                    
                                    def set(self, name, value):
                                        self._ns[self.key(name)] = value
                                        return self
                                    
                                    def clear(self, name):
                                        # XXX Should be named 'delete' because clear might mean all.
                                        del self._ns[self.key(name)]
                                        return self
                                    
                                    def __getitem__(self, name):
                                        return self.get(name)
                                    def __setitem__(self, name, value):
                                        self.set(name, value)
                            
                                    def __call__(self, name):
                                        return self.__class__(self.key(name), ns = self._ns)
                            
                                    def ensure(self, name, procedure, *args, **kwd):
                                        try: return self[name]
                                        except KeyError:
                                            task = vmCurrentTask()
                        
                                            new = task.swapFrameCall \
                                                (resolve_procedure(procedure),
                                                 arguments = args,
                                                 keywords = kwd)
                        
                                            @new.onComplete
                                            def storeCache(frame, *error):
                                                if error[1] is None:
                                                    self[name] = task.stack[-1]
                        
                                            storeCache._completionTransferOnSwap = True
                        
                                            raise new.outer
                        
                                __return = Cache(name)
                            
                        
                        reference:
                            def init$(name):
                                private$(.).name = name
                                private$(.).ns = keywords$('ns', mapping())
                            
                            def key(name):
                                return '%s-%s' % [private$(.).name, name]
                            
                            def get(name):
                                return private$(.).ns[.key(name)]
                            
                            def set(name, value):
                                private$(.).ns[.key(name)] = value
                                return .
                            
                            def clear(name):
                                # XXX Should be named 'delete' because clear might mean all.
                                del$(.key(name), private$(.).ns)
                                return .
                            
                            def getItem$(name):
                                return .get(name)
                            def setItem$(name, value):
                                .set(name, value)
                            
                            def call$(name):
                                return $(..api, .key(name), ns = private$(.).ns)
                            
                            def ensure(name, procedure):
                                try: return .[name]
                                except key$error:
                                    r = act(procedure, args$slice(2), keywords$())
                                    .[name] = r
                            
                                    return r
                            
                        
                        # instance = $(..api, '')
                        instance = new('')
                        
                        def get$(name):
                            return instance.get(name)
                        def set$(name, value):
                            return instance.set(name, value)
                        
                        def context$(name):
                            return instance(name)
                        
                        
            replication:
                agent:
                    programmer: itham
                    program::
                        def moduleChanged(path, newContent):
                            name = nodeOwner(path)
                            if name:
                                st = structure(string(..events[name]))
                                path = '/'.join(path)
                        
                                try: changed = st[path]['changed']
                                except key$error: pass
                                else:
                                    return act(securityContext(name), \
                                               [keywords$().pop('core$', act.call), changed] + \
                                               args$slice(2), \
                                               mapping(keywords$(), environment = st, \
                                                       newContent = newContent, \
                                                       path = path, reload = true))
                        
                        def securityContext(name):
                            return run$python(code, mapping(name = name)) <- code:
                                from stuphos.kernel import securityContext, Programmer, findUserByName
                                __return = securityContext(Programmer(name), user = findUserByName(name))
                        
                        def nodeOwner$(path):
                            return run$python(code, mapping(path = path)) <- code:
                                from stuphos.kernel import vmCurrentTask
                        
                                try: __return = vmCurrentTask().libraryCore[path].programmer.principal
                                except AttributeError: pass
                        
                        
                        
                events:
                    interfaces:
                        itham:
                            owner: itham
                            content::
                                assets/Itham/testing/instance:
                                    changed(method)::
                                        if keywords$('reload', false):
                                            'kernel/info'('[%s] reloading %s' % [path$, path])
                                
                                            initialize(path)
                                            return act(create, [path] + args$())
                                
                                
        facebook::
            def analyze(mobile):
                pass
            
            
            
        generic::
            def init$(type):
                pass
            
            
            
        api::
            def tasks$panel(system, user):
                if system:
                    return 'kernel/tasks$system'()
                else:
                    return 'kernel/tasks$panel'(user)
            
            
            
        operation::
            instances = mapping$shared()
            LIFESPAN = 2 * 60
            
            def init$(taskId, startTask):
                # if not is$security$context(startTask):
                instance$.events = []
                instance$.taskId = taskId
                instance$.consumer = startTask(task$, .handleConsumer)
            
                listen(taskId, .consumer.id)
                onComplete(taskId, .consumer.id, 'false')
            
                # terminate is incompatible with false getInstanceEvents event.
                setTimeout(LIFESPAN, .consumer.post, 'false')
            
                # if taskId in instances: ...
                instances[taskId] = instance$
            
            def handleConsumer():
                while true:
                    .store('kernel/parseJson'(event$()))
            
            def store(event):
                if event == false:
                    instances[.taskId] = false
                else:
                    .events.append(event)
            
            def getEvents():
                ev = sequence(.events)
                .events.clear()
                return ev
            
            def getInstance(taskId):
                return instances[taskId]
            def getInstanceEvents(taskId):
                i = getInstance(taskId)
                if i == false:
                    return false
            
                return i.getEvents()
            
            
            
        timeout::
            def init$(delay, procedure):
                .delay = delay
                .procedure = procedure
                .args = arguments().slice(2)
            
                .task = task$(.run)
            
            def run():
                sleep(.delay)
                act(.procedure, .args)
            
            
            def doc$():
                return::
                    $.components.timeout(30, .task.terminate)
            
            
            
        messaging:
            chat::
                super$ = $.assets.Itham.server.orchestration['socket-session']
                messages = string(..configuration).structure.storage['chat@0.0.1']
                
                def init$():
                    .task = task$(.run)
                    cleanup$(., .task.id, 'close')
                
                def task$name():
                    return 'messaging session (socket:chat)'
                
                def handleCommand(command):
                    if command.startswith('from '):
                        sender = command.substring(5).strip()
                        store(sender, event$())
                
                def store(sender, content):
                    messages(sender, now(), content).save()
                
                def getAll():
                    return sequence(messages.all())
                
                return action($, ..chat)
                
                
                
            interfaces:
                configuration::
                    storage($db):
                        chat@0.0.1($table):
                            - sender: string
                            - timestamp: datetime
                            - content: string
                    
                    
                    
        interpreter:
            system:
                programmer: itham
                program::
                    def init$(paths):
                        .paths = paths
                        .modules = keywords$('modules', mapping())
                    
                    def import(name):
                        try: return .modules[name]
                        except key$error:
                            load = .find_module(name)
                            r = act(load.call$, args$slice(1), keywords$())
                            .modules[name] = r
                            return r
                    
                    def find_module(name):
                        for p in .paths:
                            if is$string(p):
                                try: module = library('%s/%s' % [p, name])
                                except value$error:
                                    continue
                    
                                module$init$v = module.init$v
                            else:
                                module$init$v = p(name)
                                if is$none(module$init$v):
                                    continue
                    
                                module = module$init$v
                                module$init$v = getmember(module, 'call$', module$init$v)
                    
                            return namespace(call$ = load.defaultCompile \
                                (__module$init$v = module$init$v, \
                                 __module = module), name = name, path = p) <- load:
                    
                                kwd = keywords$().copy()
                    
                                # Why don't these exist?
                                # del$('__module$init$v', kwd)
                                # del$('__module', kwd)
                    
                                exports = act(__module$init$v, args$(), kwd)
                    
                                if is$none(exports):
                                    return __module
                    
                                return exports
                    
                    def test():
                        gen = gen.compile()() <- gen:
                            com = $.components.interpreter.system(['components'])
                            sys = com.import('interpreter/system', live = false)
                    
                            gen = $(sys, [gen.compileArgs('name')]) <- gen:
                                module = library('gen/' + name)
                                return namespace(module = module, \
                                                 call$ = module.init$v)
                    
                            return gen
                    
                        return gen.import('code')
                    
                    
        interfaces:
            web:
                owner: itham
                content::
                    task($view):
                        debug: true
                        context($trigger)::
                            path = '/'.join(path)
                            json = request.user.securityContext('kernel/positionalCode', path, true)
                            json = 'kernel/jsonify'(json)
                            response['content_type'] = 'application/json'
                            response['content'] = json
                    
                    instructions($view):
                        context($trigger)::
                            taskId = '/'.join(path)
                            events = 'core/operation/getInstanceEvents'(taskId)
                            response['content'] = 'kernel/jsonify'(events)
                            response['content-type'] = 'application/json'
                    
                    operate($view):
                      debug: true
                      context($trigger)::
                        taskId = '/'.join(path)
                        context['taskId'] = taskId
                    
                        # def startConsumer():
                        #     return act(task$, arguments())
                    
                        user = request.user
                        if is$user(user):
                            # 'kernel/info'('[taskId] ' + taskId)
                            try: $.core.operation(taskId, user.securityContext)
                            except name$error:
                                error('No task: ' + taskId + '.\nThis is because the task was not created by a primary identity.')
                        else:
                            error('No authentication provided for task operation action.')
                    
                      template::
                        {% extends "compute/taskOperate.html" %}
                    
                    
                    
            tasks:
                owner: itham
                content::
                    data.js($view):
                        debug: true
                        context($trigger)::
                            # if request.GET.get('system') == 'true':
                            #     context['source'] = 'kernel/tasks$system'()
                            # else:
                            context['source'] = 'kernel/tasks$panel'(request.user)
                    
                            response['content_type'] = 'text/javascript'
                    
                        template::
                            function loadTasks() { {{ source|safe }} }
                    
                    init.js($view):
                        debug: true
                        content-type: text/javascript
                        content::
                            function shouldBuildTaskTable()
                            { return true; }
                    
                            function emitTaskTable(table)
                            { $('#main').append(table); table.fadeIn(); }
                    
                            window.pageOpenToplevel = parent.pageOpenToplevel;
                    
                    tasks($view):
                      context($trigger)::
                        context['system'] = request.GET.get('system', 'false')
                        context['full'] = request.GET.get('full', 'false')
                    
                      template::
                        <head>
                        <link rel="stylesheet" type="text/css" href="/application/landing.css" />
                    
                        <link rel="stylesheet" type="text/css" href="/application/portal/shell.css" />
                        <link rel="stylesheet" type="text/css" href="/application/portal/style.css" />
                    
                        <script type="text/javascript" src="/application/jquery-3.6.0.js"></script>
                        <script type="text/javascript" src="/application/portal/tasks.js"></script>
                        <script type="text/javascript" src="/application/dhtml.js"></script>
                    
                        <script type="text/javascript" src="init.js"></script>
                        <script type="text/javascript" src="data.js?system={{ system }}"></script>
                    
                        {% if full %}
                        <style type="text/css">
                        #tasks { height: 100%; }
                        </style>
                        {% endif %}
                        </head>
                    
                        <body onload="loadTasks();">
                        <div id="main"></div>
                        </body>
                    
                    
                    # HTMX
                    data-execute.js($view):
                        debug: true
                        context($trigger)::
                            response['content'] = 'kernel/tasks$panel'(request.user)
                            response['content_type'] = 'text/javascript'
                    
                    execute($view)::
                      <body>
                       <div id="tasks-container">
                        <link rel="stylesheet" type="text/css" href="/application/landing.css" />
                        
                        <link rel="stylesheet" type="text/css" href="/application/portal/shell.css" />
                        <link rel="stylesheet" type="text/css" href="/application/portal/style.css" />
                        
                        <script type="text/javascript" src="/application/jquery-3.6.0.js"></script>
                        <script type="text/javascript" src="/application/portal/tasks.js"></script>
                        <script type="text/javascript" src="/application/dhtml.js"></script>
                        
                        <script type="text/javascript" src="/application/htmx.js"></script>
                    
                        <script type="text/javascript" src="init.js"></script>
                        <script hx-get="data-execute.js" hx-trigger="load"
                                hx-swap="innerHTML"></script>
                    
                        <div id="main"></div>
                       </div>
                      </body>
                    
                    
                    
                    
            economic:
                owner: itham
                content::
                    (alias): com/runphase/views/invoices-aggregate
                    
                    
    gen:
        site-messaging:
            programmer: itham
            program::
                storage = structure('gen/site-configuration').storage
                this = ..['site-messaging']
                
                def postMessage(user, email, fullname, message):
                    username = run$python('__return = user._user.username', mapping(user = user))
                
                    e = storage.tables.message(username, email, fullname, now(), message)
                    e.save()
                
                    act(chat, [], mapping(keywords$(), entityId = e.id))
                
                def messagesAll():
                    return storage.tables.message.all()
                
                
                def socialContactArgs():
                    return call.assets.Itham.server.social.code.callArgs \
                        (this.analyzeContact$, args$(), keywords$())
                
                def chat():
                    return call.assets.Itham.server.orchestration['socket-instance'] \
                        .social(act(socialContactArgs, args$(), keywords$()))
                
                
                def analyzeContact$(session):
                    p = storage.tables.message.get('id', keywords$('entityId'))[0]
                
                    session.panelOut(render(t, mapping(post = p))) <- t:
                        <pre>
                        {{ post.message }}
                        </pre>
                
                
        'system:initialize':
            programmer: itham
            program::
                setTaskName('system:initialize')
                
                # initialize('assets/Itham/code')
                # initialize('assets/Itham/server/orchestration/messaging-instance')
                
                initialize('core/operation')
                #initialize('system/loopback')
                # initialize('system/agent')
                
                initialize('com/runphase/stripe/secret')
                
                initialize('components/services/cache/api')
                
                initialize('assets/Itham/server/orchestration/socket-instance')
                initialize('assets/Itham/server/storage/backend')
                set = 'assets/Itham/server/storage/backend/set'
                
                initialize('gen/site-messaging')
                initialize('immersion/interpreter')
                
                # initialize('lambda/jhCore/instance')
                
                #initialize('assets/Itham/server/rContent/code')
                
                initialize('assets/Itham/operation')
                #initialize('assets/Itham/server/project/code')
                initialize('assets/Itham/server/kernel/code')
                
                # initialize('lambda/jhCore/instance')
                
                #initialize('areas/rivendale/eugene')
                
                yt$store = initialize('assets/Itham/server/youtube/storage')
                
                def stop$yt$store():
                    yt$store.task.post('close')
                
                yt$store$multi = initialize('assets/Itham/server/youtube/video-multi')
                set('YT::Multi::Cntlr',yt$store$multi)
                
                # msg$start$init = initialize('components/messaging/chat')
                
                # def msg$start():
                #     return act(msg$start$init, args$())
                
                #chat$session = act(initialize('components/messaging/chat'))
                
                def loadKernel():
                    setenv$near('kernel', $.core.nativeApi('gen/kernel', string(..['kernel']['map$']).structure))
                def kernel$(name):
                    return act(kernel[name], args$slice(1), keywords$())
                def kernel$ns():
                    return 'core/api/kernel$ns'(kernel)
                
                def kernel$access(checkAccess):
                    if checkAccess('read', 'gen/kernel'): # or checkAccess('execute', 'gen/kernel'):
                        return act(kernel$, args$().slice(1), keywords$())
                
                loadKernel()
                
                initialize('assets/Itham/startup')
                
                
                
        code:
            programmer: itham
            program::
                def databaseConfigs():
                    return sequence('kernel/gen'('lookupObject', 'stuphos.db.vardb.VariableDB._Names')())
                
                
                def natives$doc():
                    natives = []
                    for name in 'kernel/natives'():
                      natives.append(mapping(['name', name], ['doc', native$doc(name)]))
                
                    return natives
                
                def render$perms(request, context):
                    # User permissions request handler.
                    if request.method == 'POST':
                      # Do revoke.
                      p = request.POST
                
                      principal = p['principal']
                      action = p['access']
                      resource = p['resource']
                
                      # Or.
                      if resource:
                        resource = 'kernel/parseJson'(resource)
                      else:
                        resource = []
                
                      request.user.securityContext(revoke, principal, resource, action)
                
                    context['permissions'] = request.user.securityContext(permissions)
                
                def render$perms$resource(request, context, path):
                    if request.method == 'POST':
                        p = request.POST
                        name = p['name']
                        access = p['access']
                        access = 'text/json/loads'(access)[0] # or revoke accepts multiple access??
                        path = p['path'].split('/')
                
                        context['revOutcome'] = request.user.securityContext(revoke, name, path, access)
                
                    path = '/'.join(path)
                    context['perms'] = render$perms$resource$path(request.user.securityContext, path)
                    context['path'] = path
                    context['pathAttr'] = path.replace('"', '\\"')
                
                def permEach(p):
                    j = 'text/json/dumps'(p['access'])
                    p['accessJson'] = j
                    p['accessJsonAttr'] = 'text/etc/safeAttr'(j)
                
                    return p
                
                def render$perms$resource$path(context, path):
                    return map(permEach, context(permissions, path))
                
                
                
                def formatQueryString(path, query):
                    # def pair(ab):
                    #     return '='.join(ab)
                
                    pairs = []
                    for i in query.items():
                        pairs.append('='.join(i))
                
                    qs = '&'.join(pairs)
                    # qs = '&'.join('kernel/map'(pair, query.items()))
                    if qs:
                        return '%s?%s' % [path, qs]
                
                    return path
                
                def serveCms(request, response, sitemap, public, path):
                    authorized = request.user.securityContext
                    path = '/'.join(path)
                
                    match = sitemap[path]
                    if is$not$none(match):
                        env = mapping(match$ = match())
                        env = mapping(env = env, cached = false) # cached = not match.active
                
                        # r = act(page, [formatQueryString(match.handlerString, request.GET)], env)
                        r = act(authorized, [page, match.handlerString], env)
                
                    else:
                        # Default match: render www interface.
                        try:
                            r = authorized(page, formatQueryString(public + '/' + path, request.GET), \
                                           post = request.POST, method = request.method)
                
                            # r = authorized(page, 'www/public/' + path)
                
                        except http$404:
                            r = mapping(content = content, status = 404) <- content:
                                HTTP 404
                
                    if is$mapping(r):
                        response.update(r)
                
                
        api:
            programmer: itham
            program::
                def route(request, url):
                    u = 'kernel/URL'(url)
                    u.setHeader('User-Agent', request.userAgent)
                
                    # u.query.update(request.GET)
                
                    content = u()
                    # content = request.user.securityContext(u)
                    content = content.content
                
                    if not isLikelyHtmlPage(url):
                        return content
                
                    # Process HTML.
                    content = content.decode('latin') # 'utf-8')
                
                    rebase = 'com/runphase/site/rebase'
                    if length(args$()) == 4:
                        target = args$()[2]
                        host = args$()[3]
                
                        return rebase(content, url, target, host)
                
                    return rebase(content, url, '_blank')
                
                def isLikelyHtmlPage(url):
                    if url.endswith('.html') or url.endswith('.htm'):
                        return true
                
                    i = url.rfind('/')
                    if i >= 0:
                        return not 'kernel/contains'(string(url).substring(i), '.')
                
                def guessMimeType(filename):
                    i = filename.find('.')
                    if i >= 0:
                        ext = string(filename).substring(i+1)
                        'kernel/info'(ext)
                        if ext == 'js':
                            return 'text/javascript'
                        if ext == 'css':
                            return 'text/css'
                        if ext == 'png':
                            return 'image/png'
                
                    return 'text/html'
                
                
                def wiki(request, response, path, host):
                    if is$deep$view(path):
                        url = 'http://network/' + '/'.join(path)
                
                        response['content'] = route(request, url, none, host)
                        response['content-type'] = 'gen/api/guessMimeType'(path[-1])
                
                        return true
                
                
                def blog(request):
                    return route(request, 'https://network')
                
                def blogServeArticle(response, url):
                    r = 'kernel/regexpr'('^([0-9]{4})/([0-9]{2})/([^/]*)$')
                    m = r.match(url)
                
                    if not is$none(m):
                        args = m.groups()
                        year = integer(args[0])
                        month = integer(args[1])
                        slug = args[2]
                
                        response['content'] = '%d/%d/%s' % [year, month, slug]
                
                        return true
                
                
                def tenantURLHandler(host):
                    pass
                
                
                def numpy():
                    return call.core.privileged.wrapObject(mapping(), 'kernel/gen'('lookupObject', 'numpy'))
                def matplotlib():
                    pass
                    defn::
                        {}
                
                    return call.core.privileged.wrapObject(wm(defn), \
                        'kernel/gen'('lookupObject', 'matplotlib.pyplot'))
                
                def plot(session, data):
                    plt = 'kernel/gen'('lookupObject', 'matplotlib.pyplot')
                    plt.plot(call.core.privileged.unwrapObject(data))
                
                    return imshow(session, plt.gcf())
                
                def imshow(session, plt):
                    data = call.core.privileged.unwrapObject(plt)
                    im = 'kernel/gen'('figure2image', data)
                    return imshow$raw(session, im)
                
                def imshow$raw(session, im):
                    im = call.core.privileged.unwrapObject(im)
                    image = 'kernel/gen'('b64pil', im)
                    return session.panelOut('<img src="' + image + '">')
                
                def typeOf(o):
                    return 'kernel/gen'('evaluate', 'type')(o)
                
                def bs4(input):
                    bs = 'kernel/gen'('lookupObject', 'bs4').BeautifulSoup
                    return 'core/privileged/wrapObject'(mapping(), bs(input))
                
                def kernel$extension():
                    'core/api/native$extension'('gen/system:initialize/kernel$ns'())
                
                def py$examine():
                    return run$python(code, mapping(ns = keywords$())) \
                    <- code:
                      from code import InteractiveConsole as IC
                      ns = dict(ns)
                      IC(locals = ns).interact()
                      __return = ns.get('__return')
                
                    pass
                
                
                py$examine$compiled$instance = 'core/nativeApi/function$' \
                    ('py$examine', source, 'ns') <- source:
                      from code import InteractiveConsole as IC
                      ns = dict(ns)
                      IC(locals = ns).interact()
                      __return = ns.get('__return')
                
                pass
                
                def py$examine$compiled():
                    return py$examine$compiled$instance(keywords$())
                
                
                def mounted$api():
                    return 'kernel/gen'('runtime')('Web.Mounted.API')
                
                def mounted$getHandlerFunction(h):
                    return run$python(get, mapping(h = h)) <- get:
                        # Dereference the run$python$compile object.
                        __return = h._callable
                
                    pass
                
                def mounted$addUrl(pattern, name, handler):
                    params = ['request'] + args$slice(3)
                    handler = act('core/nativeApi/function$', \
                                  [name, handler] + params)
                
                    handler = mounted$getHandlerFunction(handler.function)
                
                    return act(mounted$api().addMountedUrl, \
                               [pattern, handler], keywords$())
                
                def mounted$removeUrl(index):
                    return mounted$api().removeMountedUrl(index)
                
                #    updateMountedUrl = staticmethod(updateMountedUrl)
                
                
                def mounted$addUrl$conf(conf):
                    if is$list(conf):
                        return sequence(map(mounted$addUrl$conf, conf))
                            
                    args = [conf['pattern'], conf['name'], conf['handler']]
                    return act(mounted$addUrl, args + conf.get('parameters', []), \
                               conf.get('kwargs', mapping()))
                
                
                def mounted$addUrl$doc():
                    return:
                        'gen/api/mounted$addUrl' \
                            ('^(?P<path>.*)', 'default', handler, \
                             instance = .) <- handler:
                             __return = HttpResponse(f'{repr(instance)}: {repr(path)}')
                
                    pass
                
                def mounted$addUrl$conf$doc():
                    return:
                        mounted$addUrl$conf(wm(urlConf)) <- urlConf:
                            - name: default
                              pattern: '^(?P<path>.*)'
                              kwargs:
                                  instance(method)::
                                      return true
                
                              handler::
                                  __return = HttpResponse(f'{repr(instance())}: {repr(path)}')
                
                    pass
                
                
                def invoke$(name):
                    return act('kernel/gen'('lookupObject', name), args$slice(1), keywords$())
                
                
                def sysConfig$loadOptions(options):
                    cfg = 'kernel/gen'('lookupObject', 'stuphos.getConfigObject')()
                    cfg.loadSetOption(options)
                
                def sysConfig$loadOptions$sequence(options):
                    r = []
                    for o in options:
                        r.append([o['section'], o['name'], o['value']])
                
                    return r
                
                def sysConfig$loadOptions$one(option):
                    return sysConfig$loadOptions([option])
                def sysConfig$loadOptions$sequence$one(option):
                    return sysConfig$loadOptions(sysConfig$loadOptions$sequence([option]))
                
                
                def enableAgentSystem$fixtures():
                    sysConfig$loadOptions$one(option.value) <- option:
                        - AgentSystem
                        - fixtures-enabled
                        - true
                
                def installImmersion():
                    sysConfig$loadOptions$sequence$one(option.value) <- option:
                        section: Interpreter
                        name: enter-game-script
                
                        value::
                            'immersion/interpreter/enterGame' \
                                (player, security$context$new())
                
                
                def vardb$install(name, path, hard):
                    # name = string path pointing to $db item
                    # path = local filesystem path of sqlite database
                    # hard = maximum database size
                
                    return run$python(install, mapping \
                        (name = string(name), path = string(path), \
                         hard = integer(hard), flags = integer \
                            (keywords$('flags', 0)))) <- install:
                
                        from stuphos.db import dbCore, orm
                        VARDB_NS = 'sqlite' # 'primary'
                
                        name = str.__str__(name)
                
                        with dbCore.hubThread(configuration.VariableDB.namespace or VARDB_NS):
                            for cfg in orm.DatabaseConfiguration.selectBy(name = name):
                                __return = False
                                break
                
                            else:
                                orm.DatabaseConfiguration(name = name, path = str.__str__(path),
                                                          hard = hard, flags = 0) # .sync()
                
                                __return = True
                
                
                def task$libraryCore():
                    return 'kernel/callObject$'('stuphos.kernel.vmCurrentTask').libraryCore
                
                def load$fixture(name, input):
                    reload = true == keywords$('reload', false)
                    core = task$libraryCore()
                
                    return core.FixtureSet.FixtureConfig.fromConfig(name, input) \
                        .load(core, reload = reload)
                
                def load$fixture$core(core, set):
                    return act(core.fixtures.load, [], set)
                
                def load$fixture$kwd():
                    return load$fixture$core(task$libraryCore(), keywords$())
                
                def fixture$core$all():
                    r = namespace()
                    for x in task$libraryCore().fixtures.values():
                        r[x.name] = mapping(x, name = x.name)
                
                    return r
                
                
        accounts::
            def newUser(user):
                'kernel/info'('[New User] %r' % user$name(user))
            
                # Rate limit.
                # sleep(15)
            
                # quota$assign$shared(user, 'library', 'public')
                user$setQuota$compute(user, 60 * 60 * 4) # 4 hours
                user$setClaimLimit(user, 5)
            
                # Link to the main library shared quota.
                library$sharedQuota$link(name = 'main')(user, force = true)
            
            def user$name(user):
                return run$python(username, mapping(user = user)) <- username:
                    __return = user._user.username
            
            def user$name$search(name):
                return run$python(search, mapping(name = name)) <- search:
                    from django.contrib.auth.models import User
                    from stuphos.structure import UserAdapter
            
                    name = str.__str__(name)
            
                    for u in User.objects.filter(username = name):
                        __return = UserAdapter(u)
                        break
                    else:
                        raise NameError(name)
            
            
            def user$setQuota$compute(user, hard):
                run$python(compute$quota, mapping(user = user, hard = integer(hard))) \
                <- compute$quota:
                    from stuphos.kernel import vmCurrentTask
                    io = vmCurrentTask().billing.core.io
            
                    with io.newQuotaCompute(user._user.username, hard):
                        pass
            
            
            def user$setQuota$shared$library(user, hard):
                return run$python(library$quota, mapping(user = user, hard = integer(hard))) \
                <- library$quota:
                    from phsite.network.accounts import newSharedQuota, generatedUniqueSharedQuotaName, setUserQuotaLink
            
                    shared = newSharedQuota(generateUniqueSharedQuotaName(), hard)
                    setUserQuotaLink(user._user, 'library', shared, force = True)
            
                    __return = shared.name
            
            def library$sharedQuota$link():
                return run$python(link$quota, mapping(hard = keywords$('hard', none), \
                                                      name = keywords$('name', none))) \
                <- link$quota:
                    from phsite.network.accounts import libraryQuota, generateUniqueSharedQuotaName
                    from stuphos.kernel import vmCurrentTask, Native
            
                    if name is None:
                        name = generateUniqueSharedQuotaName()
            
                    task = vmCurrentTask()
                    frame = task.addFrameCall(Native(libraryQuota), arguments = [name, hard])
                    frame.procedure._run(frame)
            
                    __return = task.stack.pop()[0]
            
            def session$user(session):
                user = 'kernel/gen'('getAttr', session, '_session').user
                if is$not$none(user):
                    checkAccess(['system:session:user', 'kernel/gen'('getAttr', user, '_user').username], 'read')
                    return user
            
            
            def user$setClaimLimit(user, limit):
                return 'kernel/gen'('lookupObject', 'phsite.network.embedded.players.setUserClaimLimit') \
                    ('kernel/gen'('getAttr', user, '_user'), limit)
            
            
            def registration$purpose(user, purposeText):
                purposeText = purposeText.strip()
                if purposeText:
                    signature = 'components/services/entropy/sha256'(secretKey + purposeText.strip()) <- secretKey:
                        SECRET KEY
                
                    purposeText = render(t, mapping(text = purposeText, signature = signature)) <- t:
                        Account Registration:
                            specified purpose text
                            signature: {{ signature }}
                
                        {{ text|safe }}
                
                    # ..['site-messaging'].postMessage(user, user.email, user.username, purposeText)
            
            
        kernel:
            interfaces:
                map$::
                    - name: lookupObject
                      parameters: [name]
                    
                    - name: getAttr
                      parameters: [object, name]
                    
                    - name: dir
                      parameters: [object]
                    
                    - runtime
                    - io
                    - builtin
                    - math
                    
                    - name: evaluate
                      parameters: [expression]
                    
                    - name: eval$scope
                      parameters: [expression, scope]
                    
                    - name: unwrap
                      parameters: [wrapped]
                    
                    - name: debugCall
                      parameters: [procedure, args, kwd]
                    
                    - name: getCmdlnOption
                      parameters: [name]
                    
                    - name: b64pil
                      parameters: [image]
                    
                    - name: figure2image
                      parameters: [figure]
                    
                    
                    
                    
                runtime::
                    __return = runtime
                    
                    
                    
                io::
                    __return = io
                    
                    
                    
                builtin::
                    import builtins
                    __return = builtins
                    
                    
                    
                math::
                    import numpy
                    __return = numpy
                    
                    
                    
                lookupObject::
                    from stuphos.runtime.architecture.lookup import LookupObject
                    __return = LookupObject(name)
                    
                    
                    
                getAttr::
                    __return = getattr(object, name)
                    
                    
                    
                getCmdlnOption::
                    __return = getattr(core.cmdln['options'], name)
                    
                    
                    
                dir::
                    __return = dir(object)
                    
                    
                    
                b64pil::
                    import base64
                    from io import BytesIO
                    
                    buffered = BytesIO()
                    image.save(buffered, format="PNG")
                    img_str = base64.b64encode(buffered.getvalue())
                    
                    img_base64 = bytes("data:image/png;base64,", encoding='utf-8') + img_str
                    
                    __return = img_base64.decode()
                    
                    
                    
                figure2image::
                    """Convert a Matplotlib figure to a PIL Image and return it"""
                    from PIL import Image
                    import io
                    buf = io.BytesIO()
                    figure.savefig(buf)
                    buf.seek(0)
                    img = Image.open(buf)
                    __return = img
                    
                    
                    
                debugCall::
                    from pdb import runcall
                    __return = runcall(procedure, *args, **kwd)
                    
                    
                    
                unwrap::
                    from stuphos.runtime.architecture import wrappingObject
                    if not isinstance(wrapped, wrappingObject):
                        raise TypeError(type(wrapped))
                    
                    __return = wrapped._object
                    
                    
                    
                evaluate::
                    __return = eval(expression)
                    
                    
                    
                eval$scope::
                    __return = eval(expression, scope, scope)
                    
                    
                    
                site:
                    owner: itham
                    content::
                        callObject$(view):
                            context(trigger)::
                                if is$deep$view(path) and length(path):
                                    if path[0] == 'view':
                                        args = ['.'.join(path.slice(1)), 'kernel/getAttrUnsafe'(request, '_request')]
                                    else:
                                        args = ['.'.join(path)]
                        
                                    return act('kernel/callObject$', args, request.GET)
                        
                        security:
                            grant(alias): services/kernel/callObject$/ph/interpreter/mental/library/model/StuphOS_GrantPermission
                            itham-read-all(alias): services/kernel/security/grant?principal=itham&resource=&access=read&owner=stuph
                        
                            library(alias): services/kernel/callObject$/view/ph/interpreter/mental/library/views
                        
                        pub:
                            lib(alias): services/kernel/security/library/_viewLibrary
                            (alias): services/kernel/pub/lib?path=
                        
                        player:
                            shell(alias): services/kernel/callObject$/view/mud/player/namespace
                            (alias): services/kernel/player/shell/Itham/public?path=index.html
                        
                        
                            public(method)::
                                scatter$args('request')
                                return routes.value[path](request) <- routes:
                                    index.html(method)::
                                        return:
                        
        matplotlib:
            programmer: itham
            program::
                super$ = library($.core.isolate)
                defn = wm(defn) <- defn:
                    {}
                
                def task$name():
                    return 'matplotlib'
                
                def init():
                    .plt = ..api.matplotlib()
                
                def reset():
                    .plt.clf()
                    return .zone(defn, .plt)
                
                def render(session, value):
                    if is$none(value):
                        session('Rendering method returned no value.')
                    else:
                        ..api.imshow(session, value)
                
                
                
        vault:
            code:
                programmer: itham
                program::
                    def session$():
                        return i.value <- i:
                            hostname: vault.secure.network
                            username: itham
                            password: none
                    
                    def vaultAccount$internal(user):
                        run$python(code, mapping(user = user)) <- code:
                            from phsite.network.accounts import performVaultAccountActive
                            performVaultAccountActive(user._user)
                    
                    def vaultAccount(user):
                        data = dataAccount(user)
                        if data['email'] != '<vaulted>':
                            rpcVaultAccount($.network.portal.session.fromConfig(session$()), \
                                            data)
                    
                            vaultAccount$internal(user)
                    
                            return true
                    
                    def isVaulted(user, recorded):
                        if recorded:
                            raise(value$error, 'Recorded flag not yet implemented!')
                    
                        return dataAccount(user)['email'] == '<vaulted>'
                    
                    def escapeJsonString$ela(data):
                        i = data.find("'")
                        if i < 0 or i < data.find('"'):
                            return "'%s'" % data.replace("'", "\\'")
                    
                        return "'%s'" % data
                    
                    def rpcVaultAccount(instance$, data):
                        data = 'text/json/dumps'(data)
                        data = escapeJsonString$ela(data)
                    
                        .script(render(code, mapping(data = data))) <- code:
                            'gen/vault/code/performVaultAccount$endpoint'({{ data|safe }})
                    
                    def dataAccount(user):
                        return memory$copy(run$python(code, mapping(user = user))) <- code:
                            __return = dict(username = user._user.username,
                                            email = user._user.email)
                    
                    def storage$():
                        return structure(string(..configuration)).storage
                    
                    def performVaultAccount$endpoint(data):
                        storage$()['account@0.0.1'] \
                            (username = data['username'], email = data['email'], \
                             creation = now(), meta = '').save()
                    
                    
            interfaces:
                views:
                    owner: itham
                    content::
                        perform-vault(view):
                            context(trigger)::
                                if ..code.vaultAccount(request.user):
                                    return:
                                        Vaulted
                        
                                return:
                                    Already vaulted
                        
                        is-vaulted(view):
                            context(trigger)::
                                return 'text/json/dumps'(..code.isVaulted(request.user, \
                                    string(request.GET.get('recorded', 'false').yes))
                        
                        
                configuration:
                    owner: itham
                    content::
                        storage(db):
                            account@0.0.1(table):
                                - username: string
                                - email: string
                                - creation: datetime
                                - meta: string
                        
                        
        checkpointing:
            programmer: itham
            program::
                def init$(period, threshold):
                    .task = act(task$, [.run, period, threshold] + args$slice(2), keywords$())
                
                def run(period, threshold):
                    setTaskName('checkpointing (billing)')
                
                    period = float$(period)
                    threshold = float$(threshold)
                
                    .running = true
                
                    while .running:
                        sleep(period)
                        .(threshold)
                
                def stop():
                    .running = false
                
                
                def call$(threshold):
                    for taskCommit in .genCommits(float$(threshold)):
                        # Individually schedule the commit charge database write.
                        'kernel/info'('[checkpoint$task] %s' % taskCommit)
                        taskCommit()
                
                def genCommits(threshold):
                    # Collect all tasks over the threshold.
                    return run$python(code, mapping(threshold = threshold)) <- code:
                        from stuphos.runtime.architecture import _safe_native
                        from stuphos.kernel import vmCurrentTask
                
                        def makeCommit(task):
                            def CommitTaskCharges():
                                task.commitCharges()
                
                            CommitTaskCharges.__name__ = f'checkpoint${CommitTaskCharges.__name__} ({task.name})'
                            return _safe_native(CommitTaskCharges)
                
                        __return = vmCurrentTask().sequence([])
                
                        for task in runtime[runtime.System.Engine]:
                            # print(f'{task.computationCharge} >= {threshold}')
                            if task.computationCharge >= threshold:
                                __return.append(makeCommit(task))
                
                
                
                def doc$():
                    return:
                        # Every 5 minutes, commit charges for all tasks with more than 30 seconds compute.
                        $.gen.checkpointing(5 * 60, 30.0)
                
                
        groups::
            # This should really go in gen/accounts/groups
            
            def is$group(group):
                try: checkAccess(['system:group', group], 'true')
                except no$access:
                    return false
            
                return true
            
            def group$checkAccess(group, resource, access):
                try: checkAccess(['system:group:resource', group] + sequence(resource), access)
                except no$access:
                    return false
            
                return true
            
            def add$group(identity, group):
                return grant(identity, ['system:group', group], 'true')
            
            def list$groups():
                try: identity = keywords$('identity')
                except key$error:
                    identity = programmer()
                else:
                    checkAccess(['system:group', identity], 'list')
            
                g = []
            
                for r in permissions()[identity]['resources']:
                    path = r['pathString']
                    if path.startswith('system:group/') and r['accessString'] == 'true':
                        g.append(path.substring(13))
            
                return g
            
            
        interfaces:
            errors:
                owner: itham
                content::
                    debug.css($view)::
                        .trace-instruction,
                        {
                          border-radius: 4px;
                          border: solid thin grey;
                          background-color: rgba();
                          margin: 2px;
                          padding: 8px;
                        }
                    
                        .trace-instruction h2
                        { background-color: oldlace;
                          border-radius: 2px;
                          padding: 0px 10px 0px 8px;
                          margin: 0px; }
                    
                        .trace-instruction p
                        { padding-left: 20px; }
                    
                        .trace-stack
                        {
                          background-color: rgba(255, 255, 255, 0.8);
                          border-radius: 2px;
                          margin: 0px;
                          padding-inline-start: 0;
                          padding-left: 24px;
                          margin-left: 12px;
                        }
                    
                        .traceback
                        {
                          border-radius: 4px;
                          border: solid thin grey;
                          background-color: rgba();
                          margin: 2px 2px 6px 2px;
                          padding: 8px 8px 4px 8px;
                        }
                    
                        .traceback-name
                        {
                          margin: 2px 0px 2px 0px;
                        }
                    
                        .traceback-exception
                        {
                          margin: 2px 0px 0px 0px;
                        }
                    
                        .traceback-code
                        {
                          padding-left: 14px;
                          margin-left: 20px;
                          margin-right: 20px;
                          background-color: rgba(255, 255, 255, .2);
                        }
                    
                        .traceback-link
                        {
                        }
                    
                    
                    error-format::
                        <div class="traceback">
                          {% for frame in traceback %}
                          <div class="traceback-frame">
                            {% if frame.name %}
                            <h3 class="traceback-name">{{ frame.name }}</h3>
                            {% endif %}
                    
                            <a href="/library/{{ frame.sourceAttr }}"
                               class="traceback-link" target="_blank"
                             >{{ frame.source }}</a> ({{ frame.lineNr }}:{{ frame.position }})
                    
                            <a href="#" onclick="pageOpenToplevel('/library/{{ frame.sourceAttr }}',
                                '{{ frame.nameAttr }}', 'edit: {{ frame.nameAttr }}');">edit</a>
                    
                            <br />
                    
                            {% if frame.codeName %}
                            {% endif %}
                    
                            <pre class="traceback-code">{{ frame.code }}</pre>
                          </div>
                          {% endfor %}
                    
                          <div class="traceback-exception">
                            <h2>{{ exception.type }}: {{ exception.string }}</h2>
                          </div>
                        </div>
                    
                    
                    tracing::
                        <div class="trace-instruction">
                        <h2>{{ procName }} -- {{ instrName }} ({{ position }})</h2>
                    
                        <p>{{ arguments }}</p>
                    
                        {% if stack %}
                        <ul class="trace-stack">
                          {% for v in stack %}
                          <li>{{ v }}</li>
                          {% endfor %}
                        </ul>
                        {% endif %}
                        </div>

                
    www:
        identities:
            Itham:
                interfaces:
                    pages:
                        owner: itham
                        content::
                            handle(view):
                                context(trigger)::
                                    'gen/code/serveCms'(request, response, \
                                                        environment['sitemap'], \
                                                        'www/identities/Itham/pages', \
                                                        path)
                            
                            
                            sitemap(patterns):
                                - '^([0-9]{4})/([0-9]{2})/([^/]*)$':
                                    handler: www/identities/Itham/pages/article
                                - '^download/(.*)$':
                                    handler: www/identities/Itham/pages/download
                            
                            article(view):
                                debug: true # Turn this off for production.
                                context(trigger)::
                                    return '%s/%s/%s' % match$
                            
                            download(view):
                                debug: true
                                context(trigger)::
                                    host = request.GET.get('host', none)
                            
                                    context['path'] = match$[0]
                                    context['host'] = 'core/strings/isYesValue'(host) and \
                                                        'https://localhost:2180/' or host
                            
                                template::
                                    <a href="{{ host }}{{ path }}">{{ path }}</a>

            
        interfaces:
            superior:
                owner: itham
                content::
                    page(view):
                        debug: true
                        context(trigger)::
                            o = locals()
                            o['context'] = context
                            ns = o.copy()
                    
                            try:
                                del$('view$client', ns)
                                renderView = view$client.activateContextInferior
                    
                            except name$error e:
                                context['error'] = e
                    
                            else:
                                try: result = renderView('view(%r)' % [path], ns).result()
                                except exception e:
                                    raise(e, traceback = e$stack) # tracebackOf$(e))
                                else:
                                    if is$none(result):
                                        return act(view$client.renderTemplate, [], context)
                    
                                    return result
                    
                        template::
                            <pre>
                            {{ error.typeMessage }}
                            </pre>
                    
                    
    assets:
        Itham:
            components:
                PIL:
                    code::
                        def import(name):
                            object$defn = defn$(name, string(string(..code) + '/defn$' + name)())
                            return 'core/privileged/wrapObject'(object$defn, 'kernel/gen' \
                                ('lookupObject', 'PIL.' + name))
                        
                        def buffer():
                            return 'kernel/gen'('evaluate', 'io.buffer()')
                        def buffer$bytes():
                            return 'kernel/gen'('lookupObject', 'io.BytesIO')()
                        
                        def defn$ns():
                            # If a name is passed to import but doesn't exist within this
                            # mapping, then it's a non-importable object.
                            return mapping(Image = 'PIL.Image', \
                                           ImageDraw = 'PIL.ImageDraw')
                        
                        def defn$(name, info):
                            return mapping([defn$ns()[name], mapping([name, info])])
                        
                        def defn$Image():
                            return mapping(load = false)
                        
                        def defn$ImageDraw():
                            return mapping()

                typed-json:
                    programmer: itham
                    program::
                        def type$(typeName, value):
                            return run$python(code, mapping(typeName = typeName, value = value)) <- code:
                                from collections import namedtuple
                                __return = namedtuple(typeName or 'unnamedType', 'typeName value')(typeName, value)
                        
                        def const(value):
                            return type$('', value)
                        
                        def method(value):
                            return type$('method', value)
                        def object():
                            return type$('object', act(make$, [], keywords$()))
                        
                        def make$():
                            i = mapping()
                            for p in keywords$().items():
                                scatter(p, 'n', 'v')
                                if v.typeName:
                                    i['%s(%s)' % [n, v.typeName]] = v.value
                                else:
                                    i[n] = v.value
                        
                            return i
                        
                        def make$json():
                            return string('text/json/dumps'(act(make$, [], keywords$())))
                        
                        
                        return test.compileArgs('code', path = path$) <- test:
                            return test.defaultCompile(json = ..['typed-json'])(code = code) <- test:
                                # instance$ = json.make$json(o = json.object(json.make$(m = json.const(code))))
                                instance$ = json.make$json(o = json.object(m = json.method(code)))
                                return .value.o.create().m()
                        
                        
                expression:
                    immediate:
                        programmer: itham
                        program::
                            def immediate(source):
                                return 'kernel/callObject$'('ph.interpreter.mental.compiler_extensions.ImmediateInstanceCode', source)
                            
                            
                            def metaClass$simple(defn, name):
                                return defn
                            
                            def compile$simple(code):
                                return compile(code, types = mapping(class = immediate(metaClass$simple)))
                            
                            
                            def metaClass$defClass$inner(ns, defn, name):
                                return ns['defClass$'](name, [], defn)
                            
                            def metaClass$defClass(ns):
                                # Metaclass factory binding class definition execution scope.
                                return immediate(action(metaClass$defClass$inner, ns))
                            
                            
                            def metaClass$defClass$brokenCompile(ns):
                                # XXX It seems as though a _compile.compileArgs adds an extra None to stack...
                                return immediate(action(metaClass.compileArgs('ns', 'defn', 'name'), ns)) \
                                <- metaClass:
                                    # return defn
                                    return ns['defClass$'](name, [], defn)
                            
                                    code = f.format(defn = 'kernel/indent$'(defn), \
                                                    name = name) <- f:
                                
                                        _{name} = defClass$("{name}", [], defn) <- defn:
                                        {defn}
                                
                                        return _{name}
                                
                                    # 'kernel/info'(code)
                                
                                    return compile(code)(ns)
                            
                            
                            def compile$defClass(code):
                                # XXX When compile$ is initially called, it of course has no extra stack
                                # items.  Some point before compile() returns, here, compile$'s stack has
                                # acquired an additional None, pushed before the _compile result.
                                return compile(code, types = mapping(class = metaClass$defClass \
                                    (mapping(defClass$ = 'assets/Itham/server/kernel/class/defClass'))))
                            
                            
                            compile$impl = compile$defClass
                            # compile$impl = compile$simple
                            
                            api = compile$impl(code)() <- code:
                                a(class):
                                    def getItem$(name):
                                        return name
                            
                                b(class):
                                    def init$():
                                        .args = args$()
                                        .kwd = keywords$()
                            
                                return namespace(locals())
                            
                            
                            return api.b(x = api.a()).kwd['x'].getItem$(true)
                            
                javascript:
                    code::
                        kernel$class = 'assets/Itham/server/kernel/class/'
                        newClass$derived = string(kernel$class + 'newClass$derived')
                        defClass$wm = string(kernel$class + 'defClass$wm')
                        
                        immediate$ = 'assets/Itham/components/expression/immediate/immediate'
                        
                        
                        def newClass$derived$extension(name, cls, module, bases, args, kwd):
                            cls = namespace(create = run$python(code, mapping(module = module))) <- code:
                                def __return(*args, **kwd):
                                    return module
                        
                            return newClass$derived(name, cls, bases, args, kwd)
                        
                        def defClass$extension(name, module, bases, code):
                            cls = defClass$wm(name, code)
                        
                            return newClass$derived$extension(name, cls, module, bases, \
                                args$slice(4), keywords$())
                        
                        
                        def translator$impl(source):
                            return act(defClass$extension, ['translating_nodes_ela', 'kernel/lookup$' \
                                ('js2py.translators.translating_nodes'), [], \
                                source] + args$slice(1), keywords$())
                        
                        def translator$impl$entrypoint(ns):
                            return run$python(code, mapping(ns = ns)) <- code:
                                def __return(ele):
                                    # XXX Fail because ns['impl'] is a type, not an instance.
                                    # So, it doesn't do ClassedInstance.__getattr__ which would
                                    # dereference translating_nodes module.
                                    node = getattr(ns['impl'], ele['type'])
                        
                                    # if not node:
                                    #     raise NotImplementedError('%s is not supported!' % ele['type'])
                        
                                    # if standard:
                                    #     node = node.__dict__[
                                    #         'standard'] if 'standard' in node.__dict__ else node
                        
                                    # returnValue?
                                    return node(**ele)
                        
                        
                        def js$parse(js):
                            return 'kernel/callObject$'('js2py.translators.parse', js)
                        
                        def immediate(api):
                            return immediate$(action(load.compileArgs('api', 'source'), api)) <- load:
                                return compile(api.translate$string(source))
                        
                        
                        def translator$impl$resolve(source):
                            ns = namespace()
                            ept = translator$impl$entrypoint(ns)
                            dispatch = translator$impl(source, ept)
                        
                            ns.impl = dispatch() # act(dispatch, args$slice(1), keywords$())
                            ns.main = ept
                        
                            ns.translate$string = action(translate$string \
                                .compileArgs('main', 'parse', 'js'), ept, js$parse) \
                            <- translate$string:
                        
                                return main(parse(js))
                        
                            ns.compile = action(code.compileArgs('types', 'code'), \
                                                mapping(js = immediate(ns))) <- code:
                        
                                return compile(code, types = types)
                        
                            return ns
                        
                            doc$:
                                return translator$impl$resolve(source(path)) \
                                           .compile(js)() <- js:
                        
                                    return (js):
                        
                        
                        return translator$impl$resolve(source(string(..elemental)))
                                
                        
                    interfaces:
                        views::
                            translate(view):
                                context(trigger)::
                                    if request.method == 'POST':
                                        code = request.POST['code']
                                        
                                        i = initialize('assets/Itham/components/javascript/code')
                                        context['output'] = i.translate$string(code)
                                    
                                template::
                                    {% if output %}
                                    <pre>
                                    {{ output }}
                                    </pre>
                                    {% else %}
                                    <style type="text/css">
                                    textarea { width: 100%; height: 90%; }
                                    </style>
                            
                                    <form method="POST">
                                      <textarea name="code"></textarea><br />
                                      <input type="submit" value="Translate">
                                    </form>
                                    {% endif %}
                            
                            
                jvm:
                    programmer: itham
                    program::
                        def rhino$compile(compile, script):
                            return compile(script, types = mapping \
                                (js = 'assets/Itham/components/expression/immediate/immediate' \
                                    (act(action, [rhino$compiled$action], keywords$()))))
                        
                            usage:
                                return rhino$compile(security$context$new() \
                                    .action(compile), code) <- code:
                        
                                    return (js):
                        
                        def rhino$compiled$action(script):
                            return act(action, [rhino$eval, script], keywords$())
                        
                        
                        def rhino$context(script):
                            return context.format \
                                (retCode = keywords$('value', false) and 'return ' or '', \
                                 construct = keywords$('construct', false) and 'new ' or '', \
                                 script = script, lbrace = '{', rbrace = '}') <- context:
                        
                                __return = {construct}(function () {lbrace} {retCode}{script}; {rbrace})();
                        
                        def rhino$eval(script):
                            script = act(rhino$context, [script], keywords$())
                            # 'kernel/info'(script)
                            return rhino$exec(script).get('__return')
                        
                        
                        def rhino$exec(script):
                            rhino = 'kernel/callObject$'('stuphmud.server.jvm.rhino.getRhinoEngine')
                        
                            for kw in keywords$().items():
                                scatter(kw, 'k', 'v')
                                rhino.put(k, v)
                        
                            rhino.eval(script)
                            return rhino
                        
                            usage:
                                return act(.compile(types = mapping(js = imm \
                                    ('assets/Itham/components/jvm/rhino$eval')))) <- instance$:
                        
                                    return (js):
                                        return function () { };

                php:
                    parser:
                        programmer: itham
                        program::
                            def parse$php(code):
                                debug = keywords$('debug', false)
                            
                                parser = 'kernel/callObject$'('phply.phpparse.make_parser', debug)
                                lex = 'kernel/callObject$'('phply.phplex.lexer.clone')
                            
                                return parser.parse(code, lexer = lex, debug = debug)
                            
                            def python(code, ast):
                                return act(ast, [code])
                            
                            def python$std(code):
                                return python(code, action \
                                    ('kernel/callObject$', \
                                     'phply.pythonast.from_phpast'))
                            
                            
                            def with$sys$module(name, value, proc):
                                modules = 'kernel/lookup$'('sys.modules')
                            
                                previous = modules[name]
                                modules[name] = value
                            
                                try: r = act(proc, arg$slice(3), keywords$())
                                except exception e:
                                    modules[name] = previous
                                    raise(e)
                            
                                modules[name] = previous
                                return r
                            
                            
                            def pythonast$src():
                                return 'kernel/callObject$'('builtins.open', 'kernel/getAttrUnsafe' \
                                    ('kernel/lookup$'('phply.pythonast'), '__file__')).read()
                            
                            def python$module(src):
                                ns = keywords$('ns', none)
                                if is$none(ns):
                                    ns = 'kernel/callObject$'('builtins.module', keywords$('name'))
                            
                                return run$python(code, mapping \
                                    (src = src, ns = ns)) <- code:
                            
                                    exec(src, ns)
                                    __return = ns
                            
                            
                            def python$ast(ourAst):
                                return with$sys$module('ast', ourAst, python$module, \
                                    pythonast$src(), name = 'phply.pythonast')
                            
                            def python$ast$(ourAst, code):
                                return python(code, python$ast(ourAst).from_phpast)
                            
                            
                            def node(api, name, fields):
                                def instance$(api, name, fields, data):
                                    return action(act, api[name], \
                                        [], mapping(zip(fields, data)))
                            
                                return .action(api, name, fields)
                            
                            def phply$ast(api):
                                return .compileArgs(node = keywords$('node', node) \
                                    .action(api))() <- instance$:
                            
                                    InlineHTML = node('InlineHTML', ['data'])
                                    Block = node('Block', ['nodes'])
                                    Assignment = node('Assignment', ['node', 'expr', 'is_ref'])
                                    ListAssignment = node('ListAssignment', ['nodes', 'expr'])
                                    New = node('New', ['name', 'params'])
                                    Clone = node('Clone', ['node'])
                                    Break = node('Break', ['node'])
                                    Continue = node('Continue', ['node'])
                                    Return = node('Return', ['node'])
                                    Yield = node('Yield', ['node'])
                                    Global = node('Global', ['nodes'])
                                    Static = node('Static', ['nodes'])
                                    Echo = node('Echo', ['nodes'])
                                    Print = node('Print', ['node'])
                                    Unset = node('Unset', ['nodes'])
                                    Try = node('Try', ['nodes', 'catches', 'finally'])
                                    Catch = node('Catch', ['class_', 'var', 'nodes'])
                                    Finally = node('Finally', ['nodes'])
                                    Throw = node('Throw', ['node'])
                                    Declare = node('Declare', ['directives', 'node'])
                                    Directive = node('Directive', ['name', 'node'])
                                    Function = node('Function', ['name', 'params', 'nodes', 'is_ref'])
                                    Method = node('Method', ['name', 'modifiers', 'params', 'nodes', 'is_ref'])
                                    Closure = node('Closure', ['params', 'vars', 'nodes', 'is_ref'])
                                    Class = node('Class', ['name', 'type', 'extends', 'implements', 'traits', 'nodes'])
                                    Trait = node('Trait', ['name', 'traits', 'nodes'])
                                    ClassConstants = node('ClassConstants', ['nodes'])
                                    ClassConstant = node('ClassConstant', ['name', 'initial'])
                                    ClassVariables = node('ClassVariables', ['modifiers', 'nodes'])
                                    ClassVariable = node('ClassVariable', ['name', 'initial'])
                                    Interface = node('Interface', ['name', 'extends', 'nodes'])
                                    AssignOp = node('AssignOp', ['op', 'left', 'right'])
                                    BinaryOp = node('BinaryOp', ['op', 'left', 'right'])
                                    UnaryOp = node('UnaryOp', ['op', 'expr'])
                                    TernaryOp = node('TernaryOp', ['expr', 'iftrue', 'iffalse'])
                                    PreIncDecOp = node('PreIncDecOp', ['op', 'expr'])
                                    PostIncDecOp = node('PostIncDecOp', ['op', 'expr'])
                                    Cast = node('Cast', ['type', 'expr'])
                                    IsSet = node('IsSet', ['nodes'])
                                    Empty = node('Empty', ['expr'])
                                    Eval = node('Eval', ['expr'])
                                    Include = node('Include', ['expr', 'once'])
                                    Require = node('Require', ['expr', 'once'])
                                    Exit = node('Exit', ['expr', 'type'])
                                    Silence = node('Silence', ['expr'])
                                    MagicConstant = node('MagicConstant', ['name', 'value'])
                                    Constant = node('Constant', ['name'])
                                    Variable = node('Variable', ['name'])
                                    StaticVariable = node('StaticVariable', ['name', 'initial'])
                                    LexicalVariable = node('LexicalVariable', ['name', 'is_ref'])
                                    FormalParameter = node('FormalParameter', ['name', 'default', 'is_ref', 'type'])
                                    Parameter = node('Parameter', ['node', 'is_ref'])
                                    FunctionCall = node('FunctionCall', ['name', 'params'])
                                    Array = node('Array', ['nodes'])
                                    ArrayElement = node('ArrayElement', ['key', 'value', 'is_ref'])
                                    ArrayOffset = node('ArrayOffset', ['node', 'expr'])
                                    StringOffset = node('StringOffset', ['node', 'expr'])
                                    ObjectProperty = node('ObjectProperty', ['node', 'name'])
                                    StaticProperty = node('StaticProperty', ['node', 'name'])
                                    MethodCall = node('MethodCall', ['node', 'name', 'params'])
                                    StaticMethodCall = node('StaticMethodCall', ['class_', 'name', 'params'])
                                    If = node('If', ['expr', 'node', 'elseifs', 'else_'])
                                    ElseIf = node('ElseIf', ['expr', 'node'])
                                    Else = node('Else', ['node'])
                                    While = node('While', ['expr', 'node'])
                                    DoWhile = node('DoWhile', ['node', 'expr'])
                                    For = node('For', ['start', 'test', 'count', 'node'])
                                    Foreach = node('Foreach', ['expr', 'keyvar', 'valvar', 'node'])
                                    ForeachVariable = node('ForeachVariable', ['name', 'is_ref'])
                                    Switch = node('Switch', ['expr', 'nodes'])
                                    Case = node('Case', ['expr', 'nodes'])
                                    Default = node('Default', ['nodes'])
                                    Namespace = node('Namespace', ['name', 'nodes'])
                                    UseDeclarations = node('UseDeclarations', ['nodes'])
                                    UseDeclaration = node('UseDeclaration', ['name', 'alias'])
                                    ConstantDeclarations = node('ConstantDeclarations', ['nodes'])
                                    ConstantDeclaration = node('ConstantDeclaration', ['name', 'initial'])
                                    TraitUse = node('TraitUse', ['name', 'renames'])
                                    TraitModifier = node('TraitModifier', ['from', 'to', 'visibility'])
                            
                                    return locals()
                            
                            
                            def ast$types$(names):
                                r = []
                                for n in names.splitlines():
                                    if n:
                                        r.append([n, action(act, sequence, [n])])
                            
                                return namespace(r)
                            
                            
                            def ast$types$python():
                                return ast$types$(names) <- names:
                                    Invert
                                    Not
                                    UAdd
                                    USub
                                    And
                                    Or
                                    NotEq
                                    Lt
                                    LtE
                                    Eq
                                    Gt
                                    GtE
                                    Add
                                    Sub
                                    Mult
                                    Div
                                    Mod
                                    LShift
                                    RShift
                                    BitOr
                                    BitAnd
                                    BitXor
                                    Expr
                                    Pass
                                    Str
                                    Num
                                    Dict
                                    List
                                    Load
                                    Call
                                    Name
                                    Print
                                    Raise
                                    Return
                                    Break
                                    Continue
                                    Delete
                                    Compare
                                    In
                                    IsNot
                                    Assign
                                    Tuple
                                    Store
                                    Subscript
                                    Index
                                    Attribute
                                    Global
                                    UnaryOp
                                    BinOp
                                    BoolOp
                                    IfExp
                                    If
                                    For
                                    While
                                    TryExcept
                                    ExceptHandler
                                    Param
                                    FunctionDef
                                    ClassDef
                            
                            
                                    # stmt
                                    # arguments
                                    # keyword
                            
                            
                            def python$ast$types(code):
                                return python(code, ast$types$python().from_phpast)
                            
                            
                            def translate$(api, node):
                                scatter(node, 'name', '*data')
                                proc = api[name]
                            
                                if is$mapping(proc):
                                    proc = action(.compileArgs('join', 'api'), \
                                        proc['join-nodes'].join) <- instance$:
                            
                                        return join(map(api.translate$, args$slice(2)))
                                else:
                                    try: format = proc['format']
                                    except key$error: pass
                                    else:
                                        r = []
                                        for a in data:
                                            defn = proc['data'][a]
                            
                                            if is$string(defn) and not callable(defn):
                                                defn = string(defn)
                            
                                            r.append(act(defn, [], a))
                            
                                        proc = action(act, format.format, [], r)
                            
                                return act(proc, [api] + data) or \
                                    .format(data = 'text/json/dumps'(data)) \
                                    .strip() <- instance$:
                            
                                    .node({data})
                            
                            def translate$ela(node):
                                return translate$.action(phply$ast(api.value)) <- api:
                                    InlineHTML:
                                        format: '.htmlOut({data})'
                                        data: text/json/dumps
                            
                                    # InlineHTML(method):: #  node('InlineHTML', ['data'])
                                    #   return .format(data = 'text/json/dumps' \
                                    #       (data)).strip() <- instance$:
                            
                                    #       .htmlOut({data})
                            
                                    Block:
                                        join-nodes: '\n'
                            
                                    # Block(method):: #  node('Block', ['nodes'])
                                    #   scatter$args('api')
                                    #   return '\n'.join(map \
                                    #       (api.translate$, nodes))
                            
                                    Assignment:
                                        format: '{node} = {is_ref}'
                            
                                        is_ref(method)::
                                            return is_ref and '.ref(%s)' + \
                                                api.translate$(expr) else \
                                                api.translate$(expr)
                            
                                    # Assignment(method):: #  node('Assignment', ['node', 'expr', 'is_ref'])
                                    #   scatter$args('api')
                                    #   expr = api.translate$(expr)
                                    #   expr = is_ref and '.ref(%s)' % expr
                            
                                    #   return api.translate$(node) + ' = ' + expr
                            
                                    ListAssignment(method):: #  node('ListAssignment', ['nodes', 'expr'])
                                    New(method):: #  node('New', ['name', 'params'])
                                    Clone(method):: #  node('Clone', ['node'])
                                    Break(method):: #  node('Break', ['node'])
                                    Continue(method):: #  node('Continue', ['node'])
                                    Return(method):: #  node('Return', ['node'])
                                        scatter$args('api')
                                        node = api.translate$(node)
                                        return .format(node = 'text/json/dumps' \
                                            (node)) <- instance$:
                            
                                            return {node}
                            
                                    Yield(method):: #  node('Yield', ['node'])
                                    Global(method):: #  node('Global', ['nodes'])
                                    Static(method):: #  node('Static', ['nodes'])
                            
                                    Echo:
                                        format: '.echo({nodes})'
                                        nodes:
                                            join-nodes: ', '
                            
                                    # Echo(method):: #  node('Echo', ['nodes'])
                                    #   return '.echo(%s)' % ', '.join(map(api.translate$, nodes))
                            
                                    Echo:
                                        format: '.print({node})'
                            
                                    # Print(method):: #  node('Print', ['node'])
                                    #   return '.print(%s)' % api.translate$(node)
                            
                                    Unset:
                                        format: '.unset({nodes})'
                                        nodes:
                                            join-nodes: ', '
                            
                                    # Unset(method):: #  node('Unset', ['nodes'])
                                    #   return '.unsets(%s)' % ', '.join(map(api.translate$, nodes))
                            
                                    Try(method):: #  node('Try', ['nodes', 'catches', 'finally'])
                                    Catch(method):: #  node('Catch', ['class_', 'var', 'nodes'])
                                    Finally(method):: #  node('Finally', ['nodes'])
                                    Throw(method):: #  node('Throw', ['node'])
                                    Declare(method):: #  node('Declare', ['directives', 'node'])
                                    Directive(method):: #  node('Directive', ['name', 'node'])
                                    Function(method):: #  node('Function', ['name', 'params', 'nodes', 'is_ref'])
                                        # FunctionDefinitions require scope simply to manage the symbolic operational unit.
                            
                                    Method(method):: #  node('Method', ['name', 'modifiers', 'params', 'nodes', 'is_ref'])
                                    Closure(method):: #  node('Closure', ['params', 'vars', 'nodes', 'is_ref'])
                                    Class(method):: #  node('Class', ['name', 'type', 'extends', 'implements', 'traits', 'nodes'])
                                    Trait(method):: #  node('Trait', ['name', 'traits', 'nodes'])
                                    ClassConstants(method):: #  node('ClassConstants', ['nodes'])
                                    ClassConstant(method):: #  node('ClassConstant', ['name', 'initial'])
                                    ClassVariables(method):: #  node('ClassVariables', ['modifiers', 'nodes'])
                                    ClassVariable(method):: #  node('ClassVariable', ['name', 'initial'])
                                    Interface(method):: #  node('Interface', ['name', 'extends', 'nodes'])
                            
                                    # AssignOp(method):: #  node('AssignOp', ['op', 'left', 'right'])
                                    #     return '%s %s %s' % [api.translate$(left), op, api.translate$(right)]
                                    # BinaryOp(method):: #  node('BinaryOp', ['op', 'left', 'right'])
                                    #     return '%s %s %s' % [api.translate$(left), op, api.translate$(right)]
                            
                                    AssignOp:
                                        format: '{left} {op} {right}'
                                    BinaryOp:
                                        format: '{left} {op} {right}'
                            
                                    UnaryOp:
                                        format: '{op} {expr}'
                            
                                    # UnaryOp(method):: #  node('UnaryOp', ['op', 'expr'])
                                    #     return '%s %s' % [op, api.translate$(expr)]
                            
                                    TernaryOp:
                                        format: '{iftrue} and {expr} or {iffalse}'
                            
                                    # TernaryOp(method):: #  node('TernaryOp', ['expr', 'iftrue', 'iffalse'])
                                    #     return '%s and %s or %s' % \
                                    #       [api.translate$(iftrue), \
                                    #        api.translate$(expr), \
                                    #        api.translate$(iffalse)]
                            
                                    PreIncDecOp(method):: #  node('PreIncDecOp', ['op', 'expr'])
                                    PostIncDecOp(method):: #  node('PostIncDecOp', ['op', 'expr'])
                                    Cast(method):: #  node('Cast', ['type', 'expr'])
                                    IsSet(method):: #  node('IsSet', ['nodes'])
                                    Empty(method):: #  node('Empty', ['expr'])
                            
                                    Eval:
                                        format: '.eval({expr})'
                                        expr: text/json/dumps
                            
                                    # Eval(method):: #  node('Eval', ['expr'])
                                    #   return .format(expr = 'text/json/dumps' \
                                    #       (expr)).strip() <- instance$:
                            
                                    #       .eval({expr})
                            
                                    Include(method):: #  node('Include', ['expr', 'once'])
                            
                                    Require:
                                        format: '.require({expr}, {once})'
                                        expr: text/json/dumps
                                        once: text/json/dumps
                            
                                    # Require(method):: #  node('Require', ['expr', 'once'])
                                    #   return .format \
                                    #       (expr = 'text/json/dumps'(expr), \
                                    #        once =  = 'text/json/dumps'(once)) \
                                    #       .strip() <- instance$:
                            
                                    #       .require({expr}, {once})
                            
                                    Exit(method):: #  node('Exit', ['expr', 'type'])
                                        return .format \
                                            (expr = 'text/json/dumps'(expr), \
                                             type =  = 'text/json/dumps'(type)) \
                                            .strip() <- instance$:
                            
                                            .exit({expr}, {once})
                            
                                    Silence(method):: #  node('Silence', ['expr'])
                                        return api.translate(expr)
                            
                                    MagicConstant(method):: #  node('MagicConstant', ['name', 'value'])
                                    Constant(method):: #  node('Constant', ['name'])
                                        # return 'const %s;' % api.translate$(name)
                                        return 'text/json/dumps'(name)
                            
                                    Variable(method):: #  node('Variable', ['name'])
                                        return '.[%s]' % 'text/json/dumps'(name)
                            
                                    StaticVariable(method):: #  node('StaticVariable', ['name', 'initial'])
                                    LexicalVariable(method):: #  node('LexicalVariable', ['name', 'is_ref'])
                                    FormalParameter(method):: #  node('FormalParameter', ['name', 'default', 'is_ref', 'type'])
                                    Parameter(method):: #  node('Parameter', ['node', 'is_ref'])
                                    FunctionCall(method):: #  node('FunctionCall', ['name', 'params'])
                                        return api.translate$(name) + '(' + ', '.join(map(api.translate$, params)) + ')'
                            
                                    Array(method):: #  node('Array', ['nodes'])
                                        return '[' + ', '.join(map(api.translate$, params)) + ']'
                            
                                    ArrayElement(method):: #  node('ArrayElement', ['key', 'value', 'is_ref'])
                                        if is_ref:
                                            return '.refIndex(' + api.translate$(key) + ', ' + api.translate$(value) + ')'
                            
                                        return api.translate$(value) + '[' + api.translate$(key) + ']'
                            
                                    ArrayOffset(method):: #  node('ArrayOffset', ['node', 'expr'])
                                    StringOffset(method):: #  node('StringOffset', ['node', 'expr'])
                                    ObjectProperty(method):: #  node('ObjectProperty', ['node', 'name'])
                                        return api.translate$(node) + '.' + api.translate$(name)
                            
                                    StaticProperty(method):: #  node('StaticProperty', ['node', 'name'])
                                    MethodCall(method):: #  node('MethodCall', ['node', 'name', 'params'])
                                        return api.translate$(node) + '.' + api.translate$(name) \
                                               + '(' + ', '.join(map(api.translate$, params)) + ')'
                            
                                    StaticMethodCall(method):: #  node('StaticMethodCall', ['class_', 'name', 'params'])
                            
                                    If(method):: #  node('If', ['expr', 'node', 'elseifs', 'else_'])
                                        r = []
                            
                                        r.append('if %s:' % api.translate$(expr))
                                        r.append('kernel/indent$'(api.translate$(node)))
                            
                                        for el in elseifs:
                                            r.append(api.translate$(el))
                            
                                        if else_:
                                            r.append(api.translate$(else_))
                            
                                        return '\n'.join(r)
                            
                                    ElseIf(method):: #  node('ElseIf', ['expr', 'node'])
                                        return 'elif %s:\n%s' % \
                                            [api.translate$(expr), \
                                             'kernel/indent$' \
                                                (api.translate$(node))]
                            
                                    Else(method):: #  node('Else', ['node'])
                                        return 'else:\n%s' % \
                                            'kernel/indent$' \
                                                (api.translate$(node))
                            
                                    While(method):: #  node('While', ['expr', 'node'])
                                        return 'while %s:\n%s' % \
                                            [api.translate$(expr), \
                                             'kernel/indent$' \
                                                (api.translate$(node))]
                            
                                    DoWhile(method):: #  node('DoWhile', ['node', 'expr'])
                                    For(method):: #  node('For', ['start', 'test', 'count', 'node'])
                            
                                    Foreach(method):: #  node('Foreach', ['expr', 'keyvar', 'valvar', 'node'])
                                        return 'for kv in %s:\n%s\n%s' % \
                                            [api.translate$(expr), \
                            
                                             'kernel/indent$' \
                                                ('scatter(kv, %s, %s)' % \
                                                    [api.translate$(keyvar),
                                                     api.translate$(valvar)]), \
                            
                                             'kernel/indent$' \
                                                (api.translate$(node))]
                            
                                    ForeachVariable(method):: #  node('ForeachVariable', ['name', 'is_ref'])
                                        return is_ref and '.refVar(%s)' % api.translate$ \
                                            (name) or api.translate$(name)
                            
                                    Switch(method):: #  node('Switch', ['expr', 'nodes'])
                                    Case(method):: #  node('Case', ['expr', 'nodes'])
                                    Default(method):: #  node('Default', ['nodes'])
                                    Namespace(method):: #  node('Namespace', ['name', 'nodes'])
                                        return '%s(object):\n%s' % [api.translate$(name), \
                                            'kernel/indent$'(api.translate$(nodes))]
                            
                                    UseDeclarations(method):: #  node('UseDeclarations', ['nodes'])
                                    UseDeclaration(method):: #  node('UseDeclaration', ['name', 'alias'])
                            
                                    ConstantDeclarations(method):: #  node('ConstantDeclarations', ['nodes'])
                                        return '.constants(%s)' % ', '.join(map(api.translate$, nodes))
                            
                                    ConstantDeclaration(method):: #  node('ConstantDeclaration', ['name', 'initial'])
                                        return initial and '[%s, %s]' % \
                                            ['text/json/dumps'(name), api.translate$(initial)] \
                                            or 'text/json/dumps'(name)
                            
                                    TraitUse(method):: #  node('TraitUse', ['name', 'renames'])
                                    TraitModifier(method):: # from', 'to', 'visibility'])
                            
                            
                            def compile$(phpCode):
                                scatter(args$slice(1), ['args', []], ['kwArgs', mapping()])
                            
                                return act(translate$ela(parse$php(phpCode)) \
                                    .compileArgs, args, kwArgs)
                            
                            def compile$call(php):
                                return act(compile$(php))
                            
                                usage:
                                    return compile$call(php) <- php:
                                        <?php ?>
                            
                            
                            application:
                                platform::
                                    def php$generate(appContext):
                                        compile$ = 'assets/Itham/components/php/parser/compile$'
                            
                                        return appContext(compile$(code, [], \
                                            mapping(runtime = php$runtime()))) <- code:
                            
                                            <?php ?>
                            
                            
                            scatter$args(['php', php]) <- php:
                                <?php ?>
                            
                            
                            # return python$ast$types(parse$php(php))
                            return python$std(parse$php(php))
                            
                bs4:
                    programmer: itham
                    program::
                        privateClass(object):
                            # i = private$($(path$), path$)
                        
                            # def set(n, v):
                            #   setmember(i, n, v)
                            # def get(n):
                            #   return getmember(i, n)
                        
                        
                            def init$():
                                if not keywords$('stub', false):
                                    .r = native('private$', .)
                        
                            def generate(length):
                                alphabet = keywords$('alphabet', 'abcdefghiojklmnopqrstuv')
                                return ''.join(map(action(choice, alphabet), range(length)))
                        
                            def new(key):
                                try: getmember(.r, key)
                                except name$error:
                                    setmember(.r, key, keyword$('private$')($(path$, stub = true)))
                                else:
                                    raise attr$error('key already exists')
                        
                                return namespace(object = ., \
                                    get = .get.action(key), \
                                    set = .set.action(key))
                        
                        
                            def get(key, name):
                                return getmember(getmember(.r, key), name)
                            def set(key, name, value):
                                return setmember(getmember(.r, key), name, value)
                        
                        
                            def private$(instance, path):
                                return setCodeSource(native \
                                    ('private$', instance), path)
                        
                        
                            def setCodeSource(prv, path):
                                if is$string(path):
                                    path = path.split('/')
                        
                                'kernel/callObject$' \
                                    ('builtins.object.__setattr__', \
                                     prv, '_thisCodeSource', path)
                        
                                return prv
                        
                        
                        # data = privateClass.create().new \
                        #   (privateClass.generate(40), \
                        #    private$ = private$)
                        
                        # data.set('value', true)
                        # data.get('value')
                        
                        
                        def setModuleVariable(o, n, v):
                            pass
                        
                        def extend(o):
                            set = action(act, action(setModuleVariable, o))
                        
                            for kw in keywords$().items():
                                set(kw)
                        
                            return o
                        
                        
                        pageClass = extend(pageClass, \
                            super$ = privateClass, extend = extend, \
                            privateClass = privateClass) <- pageClass(object):
                        
                            def init$(input):
                                # todo: super$init
                                .private = action(native, 'private$')
                                .i = .new(.generate(80), private$ = .private)
                                .i.set('doc', 'kernel/callObject$'('bs4.BeautifulSoup', input))
                                .r.doc = action(.i.get, 'doc')
                        
                            def iter$():
                                for node in .r.doc():
                                    return nodeClass.create(.private, node)
                        
                            def prettify():
                                return .r.doc().prettify()
                        
                        
                            nodeClass = extend(nodeClass, super$ = privateClass) \
                            <- nodeClass(object):
                                def init$(private, node):
                                    # todo: super$init
                                    .i = .new(.generate(80), private$ = private)
                                    .i.set('node', node)
                                    .r.node = action(.i.get, 'node')
                        
                                def getItem$(name):
                                    if name == 'name':
                                        return .r.node().name
                        
                        
                        def prettify():
                            scatter$args(['html', html]) <- html:
                                <document pretty="true" />
                        
                        
                            return string('/'.join(path$)).init$v \
                                (code = code, html = html) <- code:
                        
                                return bs4(html).prettify()
                        
                        
                        return keywords$('code', .).compileArgs \
                            (html = keywords$('html', html), \
                             bs4 = pageClass.create) \
                        
                        <- instance$:
                            return map(.compileArgs('node'), \
                                       bs4(html).iter$()) <- instance$:
                        
                                return node['name']
                        
                        <- html:
                            <document value="default" />

                social:
                    code:
                        programmer: itham
                        program::
                            initialize(string(..storage))
                            
                            
                            # Rendering & Dispatch.
                            def render$(message):
                                type = message.get('type')
                                if type == 'call':
                                    method = string(message['method'])
                            
                                    args = message.get('parameters', [])
                                    kwd = message.get('keywords', mapping())
                            
                                    kwd.update(keywords$())
                            
                                    try: return act(keywords$('context', act.call), \
                                                    [method] + args + args$slice(1), \
                                                    kwd)
                            
                                    except no$symbol$error e:
                                        return e
                            
                            def callArgs(method, args, kwd):
                                return mapping(type = 'call', method = string(method), \
                                               parameters = args, keywords = kwd)
                            
                            def callArgs$(method):
                                return callArgs(method, args$slice(1), keywords$())
                            
                            
                            # API.
                            def socialCallArgs():
                                return callArgs(..code.renderSocial$, args$(), keywords$())
                            
                            def renderSocial$():
                                try: videoUrl = keywords$()['videoUrl']
                                except key$error: return ''
                                else: return fb$video$iframe$html \
                                    (videoUrl, keywords$().get('title', ''))
                            
                            
                            def chat():
                                return ...orchestration['socket-instance'].social \
                                    (act(socialCallArgs, args$(), keywords$()))
                            
                            
                            # Web Component.
                            def parseWidthHeight(args, s, defaultWidth, defaultHeight):
                                if length(args) >= s + 1:
                                    width = args[s]
                                else:
                                    width = defaultWidth
                            
                                if length(args) >= s + 2:
                                    height = args[s + 1]
                                else:
                                    height = defaultHeight
                            
                                return [width, height]
                            
                            def post$fb$video():
                                # Relies on avatar interface.
                                return::
                                    <iframe src="/page/assets/Itham/avatar/fb-frame?url={{ url }}"
                                            style="width: {{ width }}; height: {{ height }}"
                                     ></iframe>
                            
                                pass
                            
                            def fb$video(instance$, url):
                                wh = parseWidthHeight(args$(), 2, 500, 300)
                                url = 'text/etc/safeAttr'(url)
                            
                                .(.messages.panelHtml(native('render', post$fb$video(), \
                                    mapping(url = url, width = wh[0], height = wh[1]))))
                            
                            def fb$video$iframe$fmt():
                                return::
                                    <style type="text/css">
                                    .fb-post { border-radius: 4px; margin: 4px; }
                                    .fb-post-control { border: solid thin grey; border-radius: 4px;
                                                       padding: 2px 8px 2px 8px; }
                                    .fb-post-title { background-color: white; color: black;
                                                     padding: 2px 4px 2px 6px; }
                                    </style>
                            
                                    <fieldset class="fb-post">
                                      <legend align="right">
                                        <div class="fb-post-control" align="left">
                                          {% if postControl %}
                                          {{ postControl|safe }}
                                          {% else %}
                                          {% if title %}
                                          <div class="fb-post-title">{{ title }}</div>
                                          {% endif %}
                                          <a href="{{ url }}" target="_blank">{{ url }}</a>
                                          <a href="#" onclick="this.parentElement.parentElement.parentElement.remove();"
                                           ><img src="/application/do-close-button.png"></a>
                                          {% endif %}
                                        </div>
                                      </legend>
                            
                                      <iframe src="https://www.facebook.com/plugins/video.php?href={{ urlEncoded }}&width={{ width }}&show_text=false&height={{ height }}"
                                              width="{{ width }}" height="{{ height }}" style="border:none;overflow:hidden"
                                              scrolling="no" frameborder="0" allowfullscreen="true"
                                              allow="autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share"
                                              allowFullScreen="true"></iframe>
                            
                                    </fieldset>
                            
                                pass
                            
                            def fb$video$iframe$html(url, title):
                                wh = parseWidthHeight(args$(), 2, 500, 300)
                            
                                return native('render', fb$video$iframe$fmt(), \
                                    mapping(urlEncoded = 'text/etc/quote'(url), \
                                            url = url, width = wh[0], height = wh[1], \
                                            title = title, \
                                            postControl = keywords$().get('postControl')))
                            
                            def fb$video$iframe(instance$):
                                .panelOut(act(fb$video$iframe$html, args$().slice(1)))
                            
                            def render$post(posterId, id):
                                post = ..storage.postObject(posterId, id)
                                if is$not$none(post):
                                    return render$('text/json/loads'(post.data))
                            
                            def render$post$list(list):
                                # return sequence(map(action(act, render$post), list))
                            
                                r = []
                                for p in list:
                                    r.append(render$post(p[0], p[1]))
                            
                                return r
                            
                            def render$post$list$byIdentity(identity):
                                posts = ..storage.post$list$byIdentity(..storage.posterId(identity))
                                return render$post$list(posts)
                            
                            def render$post$list$bySession(instance$):
                                return render$post$list$byIdentity(.avatar.name.lower())
                            
                            
                            def doc$():
                                return::
                                    chat(videoUrl = '...')
                                    ..storage.postMessage \
                                        (posterId(identity), \
                                         title = 'My video', \
                                         videoUrl = '...')
                            

                    remote::
                        super$ = library($.network.portal.session)
                        
                        def fromConfigClass(class, cfg):
                            return $(class, cfg.host, cfg.username, cfg.password, true)
                        def fromConfig(cfg):
                            return fromConfigClass(..remote, cfg)
                        
                        def handleOutput(output):
                            pass # 'kernel/info'(output) # debug
                        
                        def handleError(error):
                            'kernel/info'('[source/remote] error:')
                            'kernel/info'(error)
                        
                        def getLocalSource(path):
                            # Blocks.  Don't call from handler methods.
                            method = 'source' # 'call.assets.Itham.server.source.local.get'
                            code = 'return %s(%s)\n' % [method, 'text/json/dumps'(path)]
                            ch = channel()
                        
                            if not .processMessages(.newAsyncCommand(code, action(.handleAsyncResponse, ch.write))):
                                return ch.read()
                        
                        def handleAsyncResponse(post, outcome, value):
                            post(value) # or, encode for data channel
                        
                        def evaluate(path):
                            args = args$().slice(1)
                            code = .getLocalSource(path)
                            action = compile(code)
                        
                            return act(action, args, keywords$())
                        
                        def call$():
                            return act(.evaluate, args$(), keywords$())
                        
                        
                        def doc$():
                            return::
                                r = 'assets/Itham/server/source/remote/fromConfig' \
                                    ((config + '/remote-source/auth').structure)
                        
                                return r('assets/Itham/server/source/deployment/code', \
                                         1, 2, 3)
                        
                                ...deployment/code::
                                    return [args$(), keywords$()]
                        
                        
                        
                storage:
                    backend::
                        map = mapping$shared()
                        
                        def get(name):
                            return map[name]
                        def set(name, value):
                            map[name] = value
                        
                        
                        
                vm:
                    code::
                        
                        
                        
                voting:
                    interfaces:
                        storage::
                            ballots($db):
                                poll($table):
                                    - nameId: string
                                    - owner: string
                                    - description: string
                            
                                vote($table):
                                    - voter: string
                                    - pollId: string
                                    - value: string
                            

                build-tier:
                    code:
                        programmer: itham
                        program::
                            def bash$():
                                return act(call.core.privileged.run$subprocess, \
                                           ['/usr/bin/bash', true] + args$())
                            
                            def make$():
                                return act(bash$, ['-c', script] + args$()) <- script:
                                    cd /home/Owner/stuph/phaseware;
                                    make -f emulation/Makefile.library $*
                            
                            
                            
                api$doc:
                    code:
                        programmer: itham
                        program::
                            def import(name):
                                return 'kernel/gen'('lookupObject', name)
                            def getAttr(o, name):
                                return 'kernel/gen'('getAttr', o, name)
                            def docOf(o):
                                return getAttr(o, '__doc__')
                            
                            def nameOf(o):
                                try: return getAttr(o, '__name__')
                                except attribute$error:
                                    return keywords$().get('default', '?')
                            
                            def fqNameOf(o):
                                try: module = getAttr(o, '__module__')
                                except attribute$error:
                                    module = '?'
                            
                                return '%s.%s' % [module, nameOf(o)]
                            
                            def eval$(s):
                                return 'kernel/gen'('evaluate', s)
                            
                            def is$module(o):
                                return eval$('isinstance')(o, import('types').ModuleType)
                            def is$class(o):
                                return eval$('isinstance')(o, eval$('type'))
                            
                            def object$members(o):
                                return ls(o) # 'kernel/gen'('dir', o)
                            def id$(o):
                                return eval$('id')(o)
                            
                            def get$memo(kwd):
                                try: return kwd['memo']
                                except key$error:
                                    return eval$('set')()
                            
                            def context$object(o):
                                return mapping(class = is$class(o), \
                                               module = is$module(o), \
                                               docInternal = docOf(o), \
                                               name = nameOf(o), \
                                               doc = doc$object(o, doc$container, doc$member, \
                                                                context$object, \
                                                                keywords$()['include'], \
                                                                memo = keywords$().get('memo'))) \
                            
                                                   <- doc$container:
                                                        <ul>
                                                        {% for m in members %}
                                                          <li>{{ m|safe }}</li>
                                                        {% endfor %}
                                                        </ul>
                            
                                                   <- doc$member:
                                                       <h4>{{ name }}</h4>
                                                       <pre>{{ docInternal }}</pre>
                                                       <div>{{ doc|safe }}</div>
                            
                            def doc$object(o, doc$module, doc$member, context, include):
                                # 'kernel/info'(string(o))
                            
                                memo = get$memo(keywords$())
                                m = []
                            
                                for n in object$members(o):
                                    try: i = getmember(o, n)
                                    except attribute$error: pass
                                    else:
                                        if not (id$(i) in memo) and include(i):
                                            memo.add(id$(i))
                                            m.append(render(doc$member, context(i, memo = memo, include = include)))
                            
                                return render(doc$module, mapping(members = m))
                            
                            def doc$module(module, include):
                                doc$member = keywords$().get('doc$member', doc$member) <- doc$member:
                                    <h4>{{ name }}</h4>
                                    <pre>{{ docInternal }}</pre>
                                    <div>{{ doc|safe }}</div>
                            
                                return doc$object(module, doc$module, doc$member, context$object, include) \
                                <- doc$module:
                                    <ul>
                                    {% for m in members %}
                                      <li>{{ m|safe }}</li>
                                    {% endfor %}
                                    </ul>
                            
                            def module$startswith(prefix, i):
                                return fqNameOf(i).startswith(prefix)
                            
                            def doc$(instance$, name):
                                .(doc$module(import(name), action(module$startswith, name)))
                            
                            
                library:
                    code::
                        def security$context(user):
                            if is$not$none(user):
                                return user.securityContext
                        
                            return security$context$new('public')
                        
                        def library$core(request):
                            name = string(request.GET.get('library'))
                            if name:
                                i = name.rfind('/')
                                if i > 0:
                                    pathConfig = name.substring(0, i)
                                    systemName = name.substring(i + 1)
                        
                                    return 'assets/Itham/server/kernel/api/synthetic$agentSystem' \
                                        (dbConnect =  string(pathConfig).structure[systemName])
                        
                            return act.call
                        
                        def library$context(request):
                            return security$context(request.user) \
                                .action(library$core(request))
                        
                        
                    interfaces:
                        views:
                            owner: itham
                            content::
                                context:
                                    LIB_ROOT: '/page/assets/Itham/server/library/view/'
                                
                                template: |
                                    {% extends "girl/library.html" %}
                                
                                view($view):
                                    debug: true
                                    context($trigger): |
                                        if is$deep$view(path):
                                            template = environment['template']
                                            r = action(unbound$method('kernel/libraryView'), \
                                                       request, \
                                                       '/'.join(path), template, \
                                                       environment['context'])
                                
                                            # 'assets/Itham/server/storage/backend/set'('lib', r)
                                            response.update((..code.library$context(request) or act.call)(r))
                                
                                
                                update-path-translate:
                                    Activity: module
                                    Interface: structure
                                
                                update(view):
                                    debug: true
                                    context(trigger)::
                                        # return run$python(code, mapping(r = request)) <- code:
                                        #     __return = r._request.read() # FILES
                                
                                        # 'gen/api/py$examine'(r = request)
                                
                                        if request.method == 'POST':
                                            if not is$deep$view(path):
                                                path = request.POST['path'].split('/')
                                                if path:
                                                    context['result'] = path
                                                    return security$context$new(request.POST['key']) \
                                                        (string('kernel/' + environment['update-path-translate'] \
                                                         [nodeType(path)])(path[-1]).setText, \
                                                        'kernel/edit'('/'.join(path.slice(0, -1))), \
                                                        run$python(code, mapping(request = request)).decode()) <- code:
                                
                                                        __return = request._request.FILES['content'].read()
                                
                                
                                    template::
                                        {% if result %}
                                        {{ result }}
                                        {% else %}
                                        curl 'https://network/library-update/com/runphase/code?key=RUNPHASE' \
                                            -X POST -d `cat com/runphase/code`
                                        {% endif %}
                                
                                upload-file(view)::
                                    <form action="/page/assets/Itham/server/library/views/update"
                                          method="POST" enctype="multipart/form-data">
                                
                                        Path: <input type="text" name="path"><br />
                                        Key: <input type="text" name="key"><br />
                                        File: <input type="file" name="content"><br />
                                        <input type="submit">
                                    </form>
                                
                                
                                upload-file-report(view):
                                    context(trigger)::
                                        # return 'gen/api/py$examine'(r = request)
                                        return run$python(code, mapping(request = request)) <- code:
                                            __return = request._request.FILES['content'].read()
                                
                                upload-file-2(view)::
                                    <form action="/page/assets/Itham/server/library/views/upload-file-report"
                                          method="POST" enctype="multipart/form-data">
                                
                                        File: <input type="file" name="content"><br />
                                        <input type="submit">
                                    </form>
                        
                api:
                    interfaces:
                        agent:
                            owner: itham
                            content::
                                api:
                                    page-stream.js(view)::
                                        const streamAgent =
                                            {statement: (stmt) =>
                                                doInterpretAgent$gz(stmt + '\n'),
                                
                                
                                             open: (factory, name, key) =>
                                                streamAgent.statement(`${name} = ${factory}(${JSON.stringify(key)})`),
                                
                                             send: (name, key, data) =>
                                                streamAgent.statement(`${name}(${JSON.stringify(key)}, ${JSON.stringify(data)})`),
                                
                                             close: (name, key) =>
                                                streamAgent.statement(`${name}(${JSON.stringify(key)})`),
                                
                                
                                             action:
                                                {prefix: 'getmember(session.channels, ',
                                                 suffix: ')',
                                
                                                 nameOf: (name) => JSON.stringify(name)},
                                
                                
                                             upload: function (name, key, stream)
                                                { if (!stream)
                                                    { stream = streamAgent; }
                                
                                                  name = stream.action.prefix +
                                                         stream.action.nameOf(name.toString()) +
                                                         stream.action.suffix;
                                
                                                  key = key.toString();
                                
                                                  stream.open('session.newChannel', name, key);
                                
                                                  return {send: (data) => stream.send(name, key, data),
                                                          close: () => stream.close(name, key)}; },
                                
                                             on: function (name, key, on)
                                                { const upload = streamAgent.upload(name, key);
                                                  on.ready((data) => upload.send(data));
                                                  on.done(() => upload.close()); }};
                                
                                
                                        // Event Document Model.
                                        const pageOpen = (eventAdd, id) => 
                                            ((on, id) =>
                                                streamAgent.on
                                                    (id('.channel').innerHTML,
                                                     id('.key').innerHTML,
                                
                                                     {ready: (callback) => on
                                                        ('agent-data-ready', (event) => callback
                                                            (event.target.responseText)),
                                
                                                      done: (callback) => on
                                                        ('agent-data-done', (event) => callback
                                                            ())}))
                                
                                                (eventAdd, (query) => id.querySelector(query));
                                
                                
                                    operation::
                                        // Operation.
                                        const doInterpretAgent$gz = (data) => console.log(data);
                                
                                        function pageUpload(document)
                                        {
                                            // Transmission.
                                            pageOpen(document.addEventListener,
                                                     document.querySelector
                                                        ('.identification'));
                                
                                            // XXX Doesn't functionally operate the event model.
                                            Array(document.querySelector('.data').children)
                                                .forEach((li) => document.dispatchEvent
                                                    (new Event('agent-data-ready',
                                                        {target: {responseText: li.textContent}})));
                                
                                            // Array(document.querySelector('.data').children)
                                            //  .forEach(function (li) { console.log(li[0]);
                                            //      document.dispatchEvent
                                            //      (new Event('agent-data-ready',
                                            //          {target: {responseText: li.textContent}})) });
                                
                                            document.dispatchEvent
                                                (new Event('agent-data-done', {}));
                                        }
                                
                                
                                upload(view):
                                    context(trigger)::
                                        if is$deep$view(path):
                                            return render(container.template.upload, \
                                                mapping(document = getmember \
                                                    (container.documents, '/'.join(path)), \
                                                    api = container.api))
                                
                                
                                template:
                                    upload::
                                        <head>
                                        <title>Upload page data on document load</title>
                                        <script type="text/javascript" src="../api/page-stream.js"></script>
                                
                                        <script type="text/javascript">
                                        {{ api.operation|safe }}
                                        </script>
                                        </head>
                                
                                        <body onload="pageUpload(document);">
                                            <div class="identification">
                                                <span class="channel">{{ document.channel }}</span>
                                                <span class="key">
                                                    {{ document.key|safe }}
                                                </span>
                                            </div>
                                
                                            <ul class="data">
                                                {{ document.data|safe }}
                                            </ul>
                                        </body>
                                
                                
                                documents:
                                    default:
                                        channel: channel X
                                        key::
                                            H4UF4HFUBUY4B4ULHURIEWRIUP43GVBRWEUIRW
                                            BVIWPIURRVUIRIUR2URI2R4H2RIURV2UIBVRBN
                                
                                        data::
                                            <li></li>
                                
                        index:
                            owner: itham
                            content::
                                view(method)::
                                    scatter$args('view')
                                
                                    if not is$string(view) and callable(view):
                                        return view(doc = container)
                                
                                    return view
                                
                                
                                default$document$view:
                                    page(method)::
                                        index = post['index']
                                        if index.isdigit():
                                            index = integer(index)
                                
                                        return render(view.template, mapping \
                                            (item = map(action(view.item.view, \
                                                doc = doc, post = post, \
                                                request = request, view = view), \
                                                doc.data[index])))
                                
                                    template::
                                      {% for data in item %}
                                      {{ data }}
                                      {% endfor %}
                                
                                
                                    item:
                                        view(method)::
                                            scatter$args('item')
                                            context = mapping(keywords$(), item = item)
                                
                                            if is$mapping(item):
                                                template = item['template']
                                                r = item['context'] \
                                                    (context = context, \
                                                     item = item, \
                                                     doc = doc, \
                                                     view = view, \
                                                     post = post, \
                                                     request = request)
                                
                                                if is$not$none(r):
                                                    return r
                                
                                            else:
                                                template:
                                                    {{ item|safe }}
                                
                                            return render(template, context)
                                
                                
                                    index(method)::
                                      r = []
                                
                                      for name in doc.data:
                                          data = doc.data[name]
                                
                                          r.append(mapping(caption = name, content = view.link.html \
                                              (name = name, data = data, doc = doc, nr = nr, view = view)))
                                
                                      return mapping(caption = doc.caption, items = r)
                                
                                    link:
                                      html(method)::
                                        return render(view.link.template, mapping \
                                            (name = name, doc = doc, data = data, \
                                             nr = nr, view = view))
                                
                                      template::
                                        {% for item in data %}
                                        <form action="page" method="POST">
                                        <input type="hidden" name="path" value="{{ doc.name }}">
                                        <input type="hidden" name="index" value="{{ name }}">
                                        <input type="submit" value="{{ nr }} - {{ name }}">
                                        </form>
                                        <br />
                                        {% endfor %}
                                
                                
                                page(view):
                                    context(trigger)::
                                        if request.method == 'POST':
                                            post = request.POST
                                        else:
                                            post = request.GET
                                
                                        name = post.pop('path').replace('\r', '')
                                        doc = container.documents
                                
                                        for doc in container.documents:
                                            # 'kernel/info'('%r' % doc.name)
                                            # 'kernel/info'('%r' % name)
                                
                                            if doc.name == name:
                                                view = container.view(doc.view)
                                
                                                return view.page(request = request, \
                                                    doc = doc, post = post, view = view)
                                
                                    usage:
                                        page?path=...&index=default
                                
                                
                                index(view):
                                    context(trigger)::
                                        x = []
                                        context['documents'] = x
                                
                                        nr = 0
                                
                                        for doc in container.documents:
                                            # i = doc.view.index(doc = doc, nr = nr)
                                            # 'kernel/info'(i)
                                            # x.append(i)
                                
                                            view = container.view(doc.view)
                                
                                            x.append(view.index \
                                                (doc = doc, nr = nr, view = view))
                                
                                            nr += 1
                                
                                
                                    template::
                                        {% for doc in documents %}
                                        <div class="document">
                                            <h2>{{ doc.caption }}</h2>
                                    
                                            {% for item in doc.items %}
                                            {{ item.content|safe }}
                                            {% endfor %}
                                        </div>
                                        {% endfor %}
                                
                                
                                documents:
                                    - caption: default
                                      view(method)::
                                        return doc.default$document$view
                                
                                      name::
                                        389HY4FG93F548YNR3U8TH54RU4873HCR4J938HUNR4H894CRIO
                                        389HY4FG93F548YNR3U8TH54RU4873HCR4J938HUNR4H894CRIO
                                        389HY4FG93F548YNR3U8TH54RU4873HCR4J938HUNR4H894CRIO
                                        389HY4FG93F548YNR3U8TH54RU4873HCR4J938HUNR4H894CRIO
                                
                                      data:
                                        default:
                                            - |
                                                <h2>Hi</h2>
                                
                interfaces:
                    async::
                        doc::
                            %parent.portal.contentWindow.doJavascriptCore
                                ('assets/Itham/server/async/install');
                        
                        install($view)::
                            var asyncCmdNr = 0;
                            var asyncCmdInstances = {};
                            var asyncCmdSerial = {};
                        
                            // Exports.
                            window.newAsyncCommand = newAsyncCommand;
                            window.newAsyncCommand$json = newAsyncCommand$json;
                        
                            window.async$json = newAsyncCommand$json;
                        
                            window.async$json$output = function(expression)
                            { return newAsyncCommand$json(expression,
                                function (v) { emit_string_pre(v.toString(), 'navajowhite'); }); }
                        
                            function newAsyncCommand$json(expression, success)
                            {
                                return newAsyncCommand('return "text/json/dumps"(' + expression + ')\n',
                                    function (value) { return success(JSON.parse(value)); });
                            }
                        
                            function newAsyncCommand(script, success)
                            /*
                                newAsyncCommand('return "text/json/dumps"(true)',
                                    function (value)
                                    {
                                        // Re-indent the JSON output.
                                        value = JSON.stringify(JSON.parse(value.toString()));
                                        emit_string_pre('Components Module Method: ' + value);
                                    }
                                );
                            */
                            {
                                var nr = asyncCmdNr;
                                asyncCmdNr++;
                        
                                asyncCmdInstances[nr] = {success: success};
                                doCommand('do-interpret-script-async', script, nr);
                            }
                        
                            messageHandlerProtocols['async-command-started'] = {
                                updateDisplay: function(m) {
                                    var commandNr = m[1];
                                    var serialId = m[2];
                        
                                    asyncCmdSerial[serialId] = commandNr;
                                }
                            };
                        
                            messageHandlerProtocols['async-command-completed'] = {
                                updateDisplay: function(m) {
                                    var serialId = m[1];
                                    var value = m[2];
                                    var nr = asyncCmdSerial[serialId];
                        
                                    asyncCmdInstances[nr].success(value);
                                }
                            };
                        
                        
                        
                    views::
                        page(view):
                            context(trigger)::
                                def lookup_resident(path):
                                    e = length(path)
                                    for i in range(1, e):
                                        lib = '/'.join(path.slice(0, i))
                        
                                        try: s = structure(lib)
                                        except: continue
                        
                                        break
                                    else:
                                        return namespace(render = render.defaultCompile \
                                            (s = s)) <- render:
                        
                                            return render(t, mapping(s = s)) <- t:
                                                {% for item in s.keys %}
                                                <a href="{{ root }}/{{ item }}">{{ item }}</a>
                                                {% endfor %}
                        
                                    while i < e:
                                        s = s[path[i]]
                        
                                    return s
                        
                        
                                access = security$context$new('public')
                        
                                if is$deep$view(path):
                                    view = lookup_resident(path)
                                    return access(view.render)
                        
                        

            telnet:
                programmer: itham
                program::
                    def init$(session, hostname, port):
                        if length(args$()) >= 5:
                            .username = args$()[3]
                            private$(.).password = args$()[4]
                        else:        
                            .username = none
                    
                        if length(args$()) >= 6:
                            .keepalive = args$()[5]
                        else:
                            .keepalive = false
                    
                        if length(args$()) >= 7:
                            .reconnect = args$()[6]
                        else:
                            .reconnect = false
                    
                        if is$string(.reconnect):
                            .reconnect = getmember(., 'reconnect$' + .reconnect)
                    
                        .session = session
                        .task = task$(.run, hostname, port)
                    
                    def run(hostname, port):
                        setTaskName('telnet (%s@%s:%d)' % [.username, hostname, port])
                        while true:
                            .telnet = 'kernel/telnet'(hostname, port)
                    
                            if .keepalive:
                                .keepalive$running = true
                                if is$none(getmember(., 'keepalive$task', none)):
                                    .keepalive$task = task$(.keepalive$run)
                    
                            if .username:
                                .telnet.sendln(.username)
                                .telnet.sendln(private$(.).password)
                                # del$['password'](.telnet)
                    
                            while true:
                                r = .handleOutput(event$())
                                if r == 'disconnect': # server disconnected.
                                    .reconnect = .disconnection
                                    break
                    
                                elif r:
                                    break
                    
                            if not .reconnect or (callable(.reconnect) and .reconnect(hostname, port)):
                                break
                    
                    
                    def handleOutput(data):
                        if data == 'stop':
                            return true
                        if data == 'disconnect':
                            return 'disconnect'
                        if is$none(.session):
                            return
                    
                        data = 'text/etc/printable'(data['data']).decode()
                        data = data.splitlines()
                    
                        msg = render(.outputHtml(), \
                                     mapping(data = data, \
                                             host = '%r' % .telnet))
                    
                        # 'kernel/info'('telnet-data:\n' + 'kernel/indent$'('\n'.join(data)))
                    
                        try: .session(.session.messages.panelHtml(msg))
                        except attribute$error:
                            .session = none
                    
                    def outputHtml():
                        return::
                            <div class="output-string"
                                 style="border: solid thin purple">
                             {% for line in data %}
                             <pre>{{ line }}</pre>
                             {% endfor %}
                            </div>
                    
                        pass
                    
                    def stop():
                        # scatter$args(['message', 'stop'])
                        message = 'stop'
                        if length(args$()) > 0:
                            message = args$()[0]
                    
                        .task.post(message)
                    
                    def disconnection(hostname, port):
                        # A reconnect event.
                        return true # end.
                    
                    def call$(message):
                        return .telnet.sendln(message)
                    
                    def keepalive$run():
                        setTaskName('keep-alive (%s@%r)' % [.username, .telnet])
                        # .keepalive$cycle = .keepalive$cycle # Don't use live.
                    
                        while .keepalive$running:
                            sleep(getmember(.session, 'keepalive$delay', 60))
                            if .keepalive$cycle():
                                break
                    
                        .keepalive$task = none
                    
                    def keepalive$stop():
                        .keepalive$running = false
                    
                    def keepalive$cycle():
                        return not .('whoami')
                    
                    
                    def stuph$connect(instance$, name, password, keepalive, reconnect):
                        return $(..telnet, ., '', 2112, \
                                 name, password, keepalive, reconnect)
                    
                    def itham$atStuph$connect(instance$):
                        return act(stuph$connect, [., 'itham', 'none'] + args$slice(1), keywords$())

            portal:
                interfaces:
                    session:
                        owner: itham
                        content::
                            login($view)::
                                <!doctype html>
                                <html>
                                <head>
                                <script type="text/javascript"
                                   src="/application/mimic.js"></script>
                                <script type="text/javascript"
                                   src="/application/portal/xmlrpc.js"></script>
                                <script type="text/javascript"
                                   src="/application/portal/session.js"></script>
                            
                                <script type="text/javascript">
                                function emit(object)
                                {
                                    const el = document.getElementById('output');
                                    el.value += object.toString() + '\n';
                                }
                            
                                function pageLoad() {
                                    if (_doLoginAction('Itham') === false)
                                    { emit('Login failed'); }
                                    else { emit('Logged succeeded: ' + gSessionId); }
                                }
                                </script>
                            
                                <style type="text/css">
                                #output { width: 500px; height: 400px; }
                                </style>
                                </head>
                            
                                <body>
                                  <button onclick="pageLoad();">Load</button>
                                  <br />
                                  <textarea id="output"></textarea>
                                </body>
                                </html>
                            
                            
            kjv:
                code:
                    programmer: itham
                    program::
                        def text$():
                            return keywords$('act', act.call)(source, 'objects/kjv')
                        
                        
                        def agency$open():
                            return $('assets/Itham/server/kernel/library/instance', \
                                     string(..['agency (synthetic database)']), 'library')
                        
                        def agency$():
                            return act(agency$open(), args$(), keywords$())
                        
                        def agency$doc():
                            return:
                                agent vardb add variables/kjv-agency.db 6000000 assets Itham kjv agency+(synthetic+database) library
                        
                        def text$synthetic():
                            return agency$(source, 'objects/kjv')
                        
                        
                        def text$lines():
                            return act(text$, [], keywords$()).splitlines().slice(0, 10000)
                        
                        def joinVerse(v):
                            f = v[0]
                            f = f.split(' ', 1)
                            nr = f[0].split(':')
                        
                            try: nr[0] = integer(nr[0])
                            except value$error:
                                # XXX Belongs to previous verse.
                                return [[-1, -1], '\n'.join(v)]
                        
                            nr[1] = integer(nr[1])
                        
                            return [nr, '\n'.join([f[1]] + v.slice(1))]
                        
                        def verses():
                            a = []
                            v = []
                        
                            for line in act(text$lines, [], keywords$()):
                                if not line:
                                    if v:
                                        a.append(joinVerse(v))
                        
                                    v = []
                                else:
                                    v.append(line)
                        
                            if v:
                                a.append(joinVerse(v))
                        
                            return a
                        
                        def chapters():
                            c = 0
                            a = []
                            r = []
                        
                            for v in act(verses, [], keywords$()):
                                nr = v[0]
                                if nr[0] > c:
                                    if a:
                                        r.append([c, a])
                                        a = []
                        
                                    c = nr[0]
                        
                                a.append(v)
                        
                            if a:
                                r.append([c, a])
                        
                            return r
                        
                        def analyze():
                            r = []
                        
                            for c in act(chapters, [], keywords$()):
                                v = c[-1]
                        
                                cf = v[ 0][1].split()[ 0]
                                ce = v[-1][1].split()[-1]
                        
                                r.append([c[0], [cf, ce]])
                        
                            return r
                        
                        
                interfaces:
                    views:
                        owner: itham
                        content::
                            text(view):
                                debug: true
                                context(trigger)::
                                    if request.GET.get('local', false):
                                        return ..code.text$()
                                    else:
                                        return ..code.text$(act = ..code.agency$)
                            
                            chapter-analysis(view):
                                debug: true
                                context(trigger)::
                                    # Run analysis for anyone that has permissions for this view, but bill them.
                                    kwd = mapping()
                                    if not request.GET.get('local', false):
                                        kwd['act'] = ..code.agency$
                            
                                    context['chapters'] = act(request.user.securityContext, \
                                        [security$context$new(billingOff = true), ..code.analyze], \
                                        kwd)
                            
                                template::
                                    {% for c in chapters %}
                                    <h2>{{ c.0 }}:</h2>
                                    <div style="padding-left: 20px">
                                    {{ c.1.0 }} - {{ c.1.1 }}
                                    </div>
                                    {% endfor %}
                            
                            
                    agency (synthetic database):
                        owner: itham
                        content::
                            library(db): { }
                            
                    agency :
                        owner: itham
                        content::
                            library(db): { }
                            

                    lisp:
                        programmer: itham
                        program::
                            json:
                                [call, {args: [x], expression:
                                    [map, {expression:
                                        [{system: backup}, [index, {system: environ}, {var: x}]]},
                                    {system: environ}]}]
                            
                            
                            yaml:
                                - call
                                - args:
                                    - x
                                  expression:
                                    - map
                                    - expression:
                                        - system: backup
                                        - - index
                                          - system: environ
                                          - var: x
                            
                                    - system: environ
                            
                            eval(lisp, eval = eval$.compiled, quote = quote.defaultCompile \
                                    (runtime = runtime.value)) <- lisp:
                            
                                (call ($ ($ args x)
                                       map ($ ($ system backup)
                                            (index ($ system environ) ($ var x))
                                            ($ system environ))))
                            
                            <- eval$:
                                scatter$args('call', '*args')
                                if isintance(call, dict):
                                    return act(call, args, namespace = keywords$ \
                                        ('namespace', mapping()))
                            
                            <- quote:
                                return .defaultCompile(runtime = runtime) <- instance$:
                                    scatter$args('call', '*args')
                            
                                    if is$string(call):
                                        call = action(runtime, call)
                            
                                    return act(action, [call] + args)
                            
                            <- runtime:
                                args(method)::
                                    return action(.compiled, args$()) <- instance$:
                                        scatter$args('defn', 'call', '*args')
                            
                                        for i in range(min(length(defn), length(args))):
                                            namespace[defn[i]] = args[i]
                            
                                        return act(call, args)
                            
                                var(method)::
                                    scatter$args('var')
                                    return namespace[var]
                            
                                system(method)::
                                    scatter$args('object')
                            
                                    return .value[object]() <- instance$:
                                        environ(method)::
                                            return 'kernel/callObject$' \
                                                ('os.environ').items()
                            
                                        backup(method)::
                                            act('data/store', args$())
                            
                            
                            def functionCall(name, args):
                                return FunctionCall(Identifer(name), list(map(expression, args)))
                            
                            def expression(node):
                                if isinstance(node, dict):
                                    return functionCall('quote', node['expression'])
                            
                                if isinstance(node, (list, tuple)):
                                    return functionCall('eval', node)
                            
                                return node
                            
                            
                            def compile$(source):
                                if is$string(source):
                                    source = parse(source)
                            
                                return compile(expression(source))
                            
                            def eval(source):
                                return compile$(source)(keywords$())
                            
                            
                            def parse(source):
                                return parser$api()['parse'](source)
                            
                            def parser$api():
                                return run$python(code, mapping(source = source)) <- code:
                                    from ph.interpreter.mental import grammar
                                    from ply import lex
                            
                                    class lispLexicon(grammar.Lexicon):
                                        tokens = grammar.Lexicon.expressional_tokens
                            
                                    lispLexer = lex.lex(module = lispLexicon)
                            
                                    def lispTokenize(s):
                                        lispLexer.input(s)
                                        return iter(lispLexer.token, None)
                            
                            
                                    class lispRules:
                                        def p_expression(self, p):
                                            '''
                                            expression : LPAREN expr_list RPAREN
                            
                                            '''
                            
                                            p[0] = p[2]
                            
                                        def p_expr_list(self, p):
                                            '''
                                            expr_list : expr_list atom
                                                      | atom
                                            '''
                            
                                            if len(p) == 3:
                                                x = p[1]
                            
                                                if isinstance(x, dict):
                                                    x['expression'].append(p[2])
                                                else:
                                                    x.append(p[2])
                            
                                                p[0] = x
                            
                                            else:
                                                x = p[1]
                            
                                                if x == '$':
                                                    p[0] = dict(expression = [x])
                                                else:
                                                    p[0] = [x]
                            
                            
                                        def p_atom(self, p):
                                            '''
                                            atom : NAME
                                                 | STRING
                                                 | NUMBER
                            
                                            '''
                            
                                            p[0] = p[1]
                            
                            
                                    class lispGrammar(grammar.Grammar):
                                        def __init__(self):
                                            self.parser = yacc.yacc(module = lispRules, start = 'expression')
                            
                                        def tokenize(self, source, debug = False):
                                            self.reset_errors()
                                            self.lexer.input(source, debug = debug)
                            
                                            while True:
                                                t = self.lexer.token()
                                                if t is None:
                                                    break
                            
                                                yield t
                            
                                        def parse(self, source):
                                            # self.reset_errors()
                            
                                            self.lexer.lexer.lineno = 1
                                            self.lexer.lineno = 1
                            
                                            try: return self.parser.parse(source, lexer = self.lexer) # , debug = debug) # , tracking = 1)
                                            finally:
                                                # self.report_errors(source = source)
                                                pass
                            
                                        # def report_errors(self, source = None):
                                        #     try:
                                        #         if self.lexical_errors or self.parse_errors:
                                        #             e = GrammaticalError(self.lexical_errors, self.parse_errors, source = source)
                            
                                        #             # todo: remove printing here.  All reported errors will be raised as an exception.
                                        #             # try: print(e.report())
                                        #             # except IOError:
                                        #             #     # This might happen if stdout gets closed!
                                        #             #     pass
                            
                                        #             raise e
                            
                                        #     finally:
                                        #         self.reset_errors()
                            
                                        # def reset_errors(self):
                                        #     self.lexical_errors = []
                                        #     self.parse_errors = []
                            
                            
                                    def parse(source):
                                        return lispGrammar().parse(source)
                            
                            
                                    __return = locals()
                            

                            
                    selection:
                        owner: itham
                        content::
                            resources:
                                application: /application
                                jquery_source: /application/jquery-3.6.0.js
                                gallery_link: /page/gen/gallery/
                            
                            
                            menu(view):
                                context(trigger)::
                                    context.setdefault('user', request.user)
                                    context['RESOURCES'] = environment['resources']
                            
                                    if request.method == 'POST':
                                        try: init_script = request.POST['init_script']
                                        except key$error: pass
                                        else: context.setdefault('init_script', init_script)
                            
                                    response.setdefault('content-type', 'text/html')
                            
                            
                                template::
                                    {% extends "menu.html" %}
                            
                                    {% block gallery_link %}{{ RESOURCES.gallery_link }}{% endblock %}
                            
                                    {% block user_init_script %}
                                    {% if init_script %}{{ init_script|safe }}{% endif %}
                                    {% endblock %}
                            
                                    {% block menu_campaigns_nonauth_link %}/page/gen/site/campaigns-redirect{% endblock %}
                            
                            
                            programmable(view)::
                                <style type="text/css">
                                textarea { width: 98%; height: 260px; }
                                </style>
                            
                                <form action="menu" method="POST">
                                    <textarea name="init_script">
                                    setTimeout(function () { alert('hi'); }, 3000);
                                    </textarea><br />
                                    <input type="submit">
                                </form>
                            
                            
                            form(view):
                                context(trigger)::
                                    return form.compiled(doc = mapping(elem = .value)) \
                            
                                    <- instance$:
                                        - search: dialog
                                          caption: Enter Document
                                          submit: Save
                                          # action: 
                            
                                          fields:
                                              - variable: name
                                                label: 'Name:'
                                                type: input
                            
                                              - variable: text
                                                text: true
                            
                                                default::
                            
                                    <- form:
                                        return '\n'.join(map(elem.compiled(), doc)) <- elem:
                                            return render.action(t) <- t:
                                                <div>
                                                <h2>{{ elem.caption }}</h2>
                            
                                                <table>
                                                {% for field in elem.fields %}
                                                    {{ field.label }}
                            
                                                    {% if field.text %}
                                                    <textarea name="{{ field.variable }}">{{ field.default }}</textarea>
                                                    {% else %}
                                                    <input type="{{ field.type }}" name="{{ field.variable }}"><br />
                                                    {% endif %}
                                                {% endfor %}
                            
                                                <tr>
                                                    <td><input type="submit" value="{{ elem.submit }}"></td>
                                                </tr>
                            
                                                </table>
                                                </div>
                            
                    math:
                        owner: itham
                        content::
                            prime$regex::
                                ^1?$|^(11+?)\1+$
                            
                            isprime(view):
                                security: authenticated
                                debug: true
                            
                                context(trigger)::
                                    if is$deep$view(path) and length(path):
                                        n = path[0]
                                        return request.user.securityContext \
                                            (security$context$new(billingOff = true), \
                                             'kernel/callObject$', 're.match', \
                                                environment['prime$regex'].strip(), \
                                                '1' * integer(n)) and 'false' or 'true'

                            
            interfaces:
                session::
                    synchronize($view):
                      context($trigger)::
                        programmes = 'kernel/parseJson'(request.body)
                        sync = 'assets/Itham/session-database/synchronize'
                        sync(request.user, programmes)
                    
                    synchronize.js($view):
                     content-type: text/javascript
                     content::
                      function programmes(storage)
                      {
                        var r = [];
                    
                        for (var o in storage)
                        {
                          if (o.substring(0, 10) == 'programme$')
                          { r.push(o.substring(10)); }
                        }
                    
                        return r;
                      }
                    
                      function send(url, storage, names)
                      {
                        var p = {};
                    
                        for (var n in names)
                        {
                          var o = storage['programme$' + names[n]];
                          p[n] = JSON.parse(o);
                        }
                    
                        return $.post(url, JSON.stringify(p));
                      }
                    
                    
                    synchronize.html($view)::
                      <script type="text/javascript" src="/application/jquery-3.6.0.js"></script>
                      <script type="text/javascript" src="/page/assets/Itham/session/synchronize.js"></script>
                    
                      <script type="text/javascript">
                      var uploadUrl = '/page/assets/Itham/session/synchronize/';
                    
                      function doUploadProgrammes()
                      { send(uploadUrl, localStorage, programmes(localStorage)); }
                    
                      function loadProgrammes()
                      {
                        var names = programmes(localStorage);
                        var ul = document.querySelector('ul');
                    
                        for (var o in names)
                        {
                          var li = document.createElement('li');
                          li.appendChild(document.createTextNode(names[o]));
                          ul.appendChild(li);
                        }
                      }
                      </script>
                    
                      <body onload="loadProgrammes()">
                        <button onclick="doUploadProgrammes()">
                          Upload Programmes
                        </button>
                    
                        <ul>
                        </ul>
                      </body>


    S:
        programmer: itham
        program::
            def get(name):
                return 'assets/Itham/server/storage/backend/get'(name)
            def set(name, value):
                return 'assets/Itham/server/storage/backend/set'(name, value)

    network:
        portal:
            session:
                programmer: itham
                program::
                    def init$(session, name, password):
                        instance$.player = 'kernel/session'('localhost:2172', name, password)
                        instance$.session = session
                        instance$.loop = act(task$, [.processSessionMessages], keywords$())
                    
                    def processSessionMessages():
                        while true:
                            act(.processMessages, [.player.messages()], keywords$())
                    
                    def processMessages(messages):
                        for msg in messages:
                            act(.processMessage, msg, keywords$())
                    
                    def processMessage(type):
                        try: handle = get$method(., 'handle$' + type)
                        except attribute$error: pass
                        else: act(handle, args$slice(1), keywords$())
                    
                    def script(script):
                        .processMessages(.player + script)
                    
                    def call$(command):
                        return .player(command)
                    
                    def handle$output(message):
                        .session.peer.sendln(message)
                    
                    
    immersion:
        commands:
            action::
                def call$(actor, command, subcmd, arguments):
                    action = $('player/commands/' + string(subcmd))
                    return action(actor, subcmd, none, arguments)
                
                
                
                
            async::
                def call$(actor, command, subcmd, arguments):
                    return 'assets/Itham/server/async-module/call$asyncCmd'(actor, command, subcmd, arguments)
                
                
                
                
            default:
                programmer: itham
                program::
                    # def init$(name):
                    #     .name = name
                    
                    def call$(mobile, cmd, subcmd, args):
                        action = string('identities/%s/commands/%s' % [mobile.name, cmd])
                    
                        try: result = action(mobile, cmd, subcmd, args)
                        except keyError:
                            result = false
                        except valueError:
                            result = false
                    
                        if not result:
                            mobile.sendln('Unknown command: %r' % cmd)
                    
                    
                    
                    
            last::
                def call$(actor, command, subcmd, arguments):
                    if arguments and arguments.strip() == 'chat':
                        posts = ['Chat History:']
                
                        i = 0
                        for p in 'components/messaging/chat/getAll'():
                            i += 1
                            p = [i, p.timestamp, p.sender, p.content]
                            p = "%2d. [%s] &G%s chatted, '%s'&N" % p
                
                            posts.append(p)
                
                        actor.peer.page('\r\n'.join(posts))
                
                        return true
                
                
                
                
            moo::
                def call$(actor, command, subcmd, arguments):
                    session = actor.peer.session
                    if not login$(session, arguments):
                        try: player = session.player$object
                        except attribute$error:
                            session.peer.sendln('You must login first!')
                        else:
                            verbCall = player(arguments)
                            if is$not$none(verbCall):
                                return verbCall()
                            else:
                                session.peer.sendln('Unknown command.')
                
                    return true
                
                def parseLoginSequence(session, args):
                    # if length(args) > 1 and args[0] == 'open' and args[1] == 'login':
                    #     return args.slice(2)
                
                    # session.peer.sendln('Usage: moo open login # and continue with form.')
                
                    # session.peer.sendln((length(args) > 0) and (args[0] == 'login'))
                
                    if (length(args) > 0) and (args[0] == 'login'):
                        auth = args.slice(1)
                        if length(auth) == 2:
                            return auth
                
                        session.peer.sendln('Usage: moo login <name> <password>')
                
                def login$(session, args):
                    args = args.split()
                    auth = parseLoginSequence(session, args)
                
                    if not is$none(auth):
                        login = 'lambda/jhCore/instance/login$'
                
                        try: player = act(login, args.slice(1))
                        except name$error: # lambda/jhCore/instance:'core'
                            session.peer.sendln('JHCore not installed.')
                        else:
                            if is$not$none(player):
                                session.player$object = player
                
                        return true
                
                
                
                
            save::
                def call$(actor, command, subcmd, arguments):
                    actor.peer.sendln('Save is automatic.')
                
                
                
                
            session_chat::
                def call$(actor, command, subcmd, arguments):
                    # try: chat = actor.peer.session.chat
                    # except attributeError: pass
                    # else: chat("%s chats, '%s'" % [actor.name, arguments.strip()])
                
                    # setTaskName('breakpoint')
                    # msg = "%s chats, '%s'" % [actor.name, arguments.strip()]
                    msg = arguments.strip()
                    actor.peer.session.chat(msg)

            
        global-command-verbs::
            super$ = library(..verbs)
            
            def init$(interface, abbrevs, session):
                super$.call.init$(., session, abbrevs)
                .interface = interface
            
            def session$name():
                return 'session$host'
            
            def interface$commands():
                return .interface.commands
            
            
            
            
        interface:
            interfaces:
                storage::
                    storage($db):
                        messages($table):
                            - tagId: string
                            - owner: string
                            - content: string
                            - timestamp: string

