'''
def messageCommand(handle, package):
    e = keywords$('engine', none)
    i = keywords$('self', none)

    self = i or namespace \
        (dataChannel = keywords$('dataChannel, none) or \
            handle.encoding.EntitySpace(), \
         engine = e or handle.Engine \
            (keywords$('appl', none) or \
             handle.Application \
                (handle.Configuration.FromString \
                    (keywords$('config'), \
                     default_section = 'Application'))))

self.api.plugApi(api.NAME, api)

    if is$none(i):
        # New peerish initialization.
        self.mode = self.engine.application.InitialMode()
        self.messenger = messageCommand.action(handle)
        self.send = action(handle.CommandMessage.handleIncomingPackage, self)

        self.engine.application.api.plugApi('messaging', handle.MessagingService())

    if is$not$none(self):
        return self.send(none, package)

newMessageCommand = messageCommand.action \
    ('kernel/lookup$seq'(handle.value)) \

    <- handle:
        - using
        - m6ab56a49c6d24ef54ee1cd19316f9a6ff9ab6fb528d26898911cbc7789445633
        - messaging


# .space = newMessageCommand('')
# .space.send(.space.dataChannel.packMessage \
#     (['messaging.interpret', \
#       programmer(), code])) <- code:

'''

from m6ab56a49c6d24ef54ee1cd19316f9a6ff9ab6fb528d26898911cbc7789445633 \
    .messaging import Engine, Command, Service, Application, Configuration

# getSystemException

# _securityContext
# _invokeCode
# _compile

class MessagingService(Service):
    def doInterpret(self, access, code):
        access = _securityContext(access)
        code = _invokeCode(lambda: access(_compile, code))
        return _invokeCode(lambda: access(code))


class CommandMessage(Engine.Message):
    def __init__(self, peer, mode, command):
        self.peer = peer
        self.mode = mode
        self.command = command

    def __repr__(self):
        return '<%s: %r>' % (self.__class__.__name__,
                             self.command)

    @classmethod
    def handleIncomingPackage(cls, self, peer, package):
        cmd = Command.FromPackage(package, self.dataChannel)
        if cmd is not None:
            self.engine.postMessage \
                (cls(peer, self.mode, cmd))

        return self

    def dispatch(self, engine):
        with engine.Controller(self.peer):
            # The client kwd names could interfere with the actual method params.
            try: response = self.mode.interpretCommand \
                (engine, self.peer, self.cmd.command,
                 *self.cmd.args, **self.cmd.kwd)

            except self.peer.ResponseDeferred as e:
                d = e.bind(self.peer, self.cmd)
                if e.tracked:
                    nr = self.cmd.serialId
                    assert nr is not None
                    assert nr not in self.peer.deferred_response
                    self.peer.deferred_response[nr] = d

            except:
                self.peer.handleCommandException \
                    (engine, self.cmd, getSystemException())
                self.peer.interruptTimeout()

            else:
                self.peer.handleCommandResponse \
                    (engine, self.cmd, response)
                self.peer.interruptTimeout()
