def methodChange(line):
	if line[:10] == '##method:':
		return line[10:]

def nodeComplete(path, method, message, args, kwd):
	if not is$string(method) and callable(method):
		node = method
	else:
		node = 'node/' + path + '/' + method

	return act(security$context$new(path), \
		[node, message] + args, kwd)

def streamMethod(stream, complete, method):
	args = args$slice(3)
	kwd = keywords$()

	message = []
	r = none

	for node in stream:
		for line in stream:
			method = methodChange(line)

			if not method:
				if line != '---':
					message.append(line)
				else:
					r = act(complete, \
						[node, method, \
						 message] + args, \
						 kwd)

					message = []

					if line == '...':
						break

	return r


def streamCpu(dev, method):
	return streamMethod \
		(dev.cpu.bus.open(), \
		 nodeComplete, method)

node:
	node:
		io(method)::
			scatter$args('message')

(view):
	context(trigger)::
		def exe(message, path):
			return page(path, mapping \
				(message = 'text/json/dumps' \
					(message)))

		context['consoleOut'] = \
			streamCpu(io.root.dev, exe, \
				'www/public/messageCpu.html')

	template::
		{% for line in consoleOut %}
		{% endfor %}


def cpu_actionOf(dev):
	return action(print, file = \
		dev.cpu.bus.open('w+b'))

	usage:
		def instance$(instance$):
			return cpu_actionOf() \
				(message.format(.) \
					.encode()) <- message:

				#S{length}.{node}#S{size}.{data}


		node = 'text/base64/decode'(node) <- node:
		data = 'text/base64/decode'(data) <- data:

		return .(mapping \
			(length = length(node), \
			 node = node, \
			 size = length(data), \
			 data = data))
