def pathNew(path):
	nr = path.number
	new = path(nr)

	if not new.exists:
		return new

	for nr in path.recycled.listing:
		new = path(nr.rootName)
		if not new.exists:
			# nr.unlink()

			return new

	else:
		nr += 1

		for i in range(work):
			new = path(nr)

			if not new.exists:
				return new


	error and raise errorClass(nr)

def pathNewHEAD(path):
	new = pathNew(path)

	# 'current' is HEAD
	current = path.current.read()

	path('current.' + current).write(new)

	return new


def writeCall(path, format, o, method, *args):
	return method([path, format, o, pathNewHEAD
		(path).write(o, format)], *args)


# action-concensus-1.ela
# task$.action(ifCall, canGo) # , 'data', procedure)


def shellCall(*args):
	(path, *args) = args

	return io.path(path) \
		.pipe(*args) # or output

def shell(path, format, *args):
	return writeCall(path, format,
		run, shellCall(*args))


def console(format, *args):
	# Format the result of the shell call.
	(path, *args) = args

	if args:
		print(shell(path, format, *args))


if __name__ == '__main__':
	# $0 path-stream-1.data0001.dataspace echo path
	from sys import argv
	args = argv[1:]

	if args:
		console('pickle', *args)


	'''
	sign(view):
		context(trigger)::
			access = request.user.securityContext
			at = string(now())

			return at + '@' + act(sign, .compiled \
				(mapping(identity = access(programmer), \
				 request = request, access = access, \
				 container = container, at = at))) \

			<- instance$:
				try: method = request.GET['page']
				except key$error:
					return [container.key, identity, at, request.path]

				try: path = request.GET['path']
				except key$error: pass
				else: method = method + '/' + path

				scatter('text/json/loads' \
					(access(page, string \
						(method).response)), \
					'key', 'path')

				return [key, identity, at, path]

				'''
